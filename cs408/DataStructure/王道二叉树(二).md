# 1、线索二叉树

- **n 个结点的二叉树，有 n + 1 个空链域。我们可以利用这些空链域来记录前驱、后继的信息。**

![](王道二叉树(二).assets/6.png)

- 如上图，D 的左子树是空链域，因为 D 没有前驱结点，是第一个结点，所以让其左子树指向NULL
- G 的左右子树都是空链域，让左子树指向其前驱结点 D，让右子树指向其后继结点 B
- E 的左右子树都是空链域，让左子树指向其前驱结点 B，让右子树指向其后继结点 A
- F 的左右子树都是空链域，让左子树指向其前驱结点 A，让右子树指向其后继结点 C
- C 的右子树是空链域，因为 C 没有后继结点，是最后一个结点，所以让其右子树指向 NULL

定义：**一个结点的左孩子指针和右孩子指针指向的是前驱和后继而不是左右孩子的话，我们把这种类型的指针称为线索，指向前驱的是前驱线索，指向后继的是后继线索。**

那么还存在一个问题，如果我们的右孩子指针指向的就是右孩子而不是后继，那么如何找后继呢？



## 1.1、线索二叉树的存储结构

普通二叉树的链式存储结点：

![](王道二叉树(二).assets/7.png)

```c
// 二叉树的结点(链式存储)
typedef struct BiTNode {
    ElemType data;
    struct BiTNode *lchild,*rchild;
}BiTNode,*BiTree;
```

线索二叉树的链式存储结点：

![](王道二叉树(二).assets/8.png)

```c
// 线索二叉树的结点
typedef struct ThreadNode{
    ElemType data;
    struct ThreadNode *lchild,*rchild;
    int ltag,rtag;						// 左、右线索标志
}ThreadNode,*ThreadTree;
```

### 1.1.1、中序线索二叉树的存储

![](王道二叉树(二).assets/9.png)









## 1.2、先序线索二叉树

![](王道二叉树(二).assets/10.png)

![](王道二叉树(二).assets/11.png)



## 1.3、后序线索二叉树

![](王道二叉树(二).assets/12.png)



## 1.4、三种线索二叉树的对比

![](王道二叉树(二).assets/13.png)

- **中序线索二叉树 ➡ 线索指向中序前驱、中序后继**
- **先序线索二叉树 ➡ 线索指向先序前驱、先序后继**
- **后序线索二叉树 ➡ 线索指向后序前驱、后序后继**



![](王道二叉树(二).assets/14.png)





# 2、二叉树的线索化

## 2.1、中序线索化

```c
// 线索二叉树的结点
typedef struct ThreadNode{
    ElemType data;
    struct ThreadNode *lchild,*rchild;
    int ltag,rtag;						// 左、右线索标志
}ThreadNode,*ThreadTree;

// 中序遍历二叉树,一边遍历一边线索化
void InThread(ThreadTree T){
    if(T != NULL){
        InThread(T->lchild);		// 中序遍历左子树
        visit(T);					// 访问根节点
        InThread(T->rchild);		// 中序遍历右子树
    }
}

// 全局变量 pre,指向当前访问结点的前驱(开始访问第一个结点,无前驱,所以指向NULL)
ThreadNode *pre = NULL;

void visit(ThreadNode *q){
    if(q->lchild == NULL){			// 如果左子树为空,则建立前驱线索
        q->lchild = pre;
        q->ltag = 1;
    }
    if(pre != NULL && pre->rchild == NULL){
        pre->rchild = q;			// 建立前驱结点的后继线索
        pre->rtag = 1;
    }
    pre = q;
}

// 中序线索化二叉树T
void CreateInThread(ThreadTree T){
    pre=NULL;						// pre初始为NULL
    if(T != NULL){					// 非空二叉树才能线索化
        InThread(T);				// 中序线索化二叉树
        if(pre->rchild == NULL){
            pre->rtag=1;			// 处理遍历的最后一个结点
        }
    }
}
```



## 2.2、先序线索化

```c
// 先序遍历二叉树,一边遍历一边线索化
void PreThread(ThreadTree T){
    if(T != NULL){
        visit(T);				// 先处理根结点
        if(T->ltag == 0){		// lchild不是前驱线索
            PreThread(T->lchild);
        }
        PreThread(T->rchild);	// 先序遍历右子树
    }
}

// 全局变量 pre,指向当前访问结点的前驱
ThreadNode *pre = NULL;
void visit(ThreadNode *q){
    if(q->lchild == NULL){			// 如果左子树为空,则建立前驱线索
        q->lchild = pre;
        q->ltag = 1;
    }
    if(pre != NULL && pre->rchild == NULL){
        pre->rchild = q;			// 建立前驱结点的后继线索
        pre->rtag = 1;
    }
    pre = q;
}

// 先序线索化二叉树T
void CreateInThread(ThreadTree T){
    pre=NULL;						// pre初始为NULL
    if(T != NULL){					// 非空二叉树才能线索化
        InThread(T);				// 中序线索化二叉树
        if(pre->rchild == NULL){
            pre->rtag=1;			// 处理遍历的最后一个结点
        }
    }
}
```

## 2.3、后序线索化

```c
// 线索二叉树的结点
typedef struct ThreadNode{
    ElemType data;
    struct ThreadNode *lchild,*rchild;
    int ltag,rtag;						// 左、右线索标志
}ThreadNode,*ThreadTree;

// 后序遍历二叉树,一边遍历一边线索化
void PostThread(ThreadTree T){
    if(T != NULL){
        PostThread(T->lchild);		// 中序遍历左子树
        PostThread(T->rchild);		// 中序遍历右子树
        visit(T);					// 访问根节点
        
    }
}

// 全局变量 pre,指向当前访问结点的前驱(开始访问第一个结点,无前驱,所以指向NULL)
ThreadNode *pre = NULL;

void visit(ThreadNode *q){
    if(q->lchild == NULL){			// 如果左子树为空,则建立前驱线索
        q->lchild = pre;
        q->ltag = 1;
    }
    if(pre != NULL && pre->rchild == NULL){
        pre->rchild = q;			// 建立前驱结点的后继线索
        pre->rtag = 1;
    }
    pre = q;
}

// 后序线索化二叉树T
void CreateInThread(ThreadTree T){
    pre=NULL;						// pre初始为NULL
    if(T != NULL){					// 非空二叉树才能线索化
        InThread(T);				// 中序线索化二叉树
        if(pre->rchild == NULL){
            pre->rtag=1;			// 处理遍历的最后一个结点
        }
    }
}
```

## 2.4、总结

![](王道二叉树(二).assets/21.png)











# 线索二叉树(王卓)

当用二叉链表作为二叉树的存储结构时，可以很方便地找到某个结点的左右孩子，但一般情况下，**无法直接找到该结点在某种遍历序列中的前驱和后继结点。**如何寻找特定遍历序列中的二叉树结点的前驱和后继？

![](王道二叉树(二).assets/17.png)

利用二叉链表中的空指针域：

如果某个结点的左孩子为空，则将空的左孩子指针域改为**指向其前驱**，如果某结点的右孩子为空，则将空的右孩子指针域改为**指向其后继**。 这种改变指向的指针称为"线索"。加上了线索的二叉树称为线索二叉树。

![](王道二叉树(二).assets/18.png)

A结点的右孩子为空，所以将右孩子指向其直接后继，但是中序遍历序列A无后继，所以为空。

B结点的左右孩子不为空，不需要线索化。

C结点的左右孩子为空，所以将左孩子指向其直接前驱，右孩子指向其直接后继。但是中序遍历序列C无前驱，所以为空，C直接后继为B，所以将C的右孩子指向B。

D结点的左右孩子不为空，不需要线索化。

E结点的左孩子为空，所以将左孩子指向其直接前驱，中序遍历序列中E结点的直接前驱为B，所以左孩子指向B。

F结点的左右孩子为空，所以将左孩子指向其直接前驱，右孩子指向其直接后继。在中序遍历序列中，F的直接前驱是D，直接后继是A，所以左孩子指向D，右孩子指向A。

G结点的左右孩子为空，所以将左孩子指向其直接前驱，右孩子指向其直接后继。在中序遍历序列中，G的直接前驱是E，直接后继是D，所以左孩子指向E，右孩子指向F。

![](王道二叉树(二).assets/19.png)

为了区分lrchild和rchild指针到底是指向孩子的指针，还是指向前驱或者后继的指针，对二叉链表中的每个结点增设两个标志域 ltag和rtag，并约定：

- ltag=0 lchild指向该结点的左孩子
- ltag=1 lchild指向该结点的前驱
- rtag=0 rchild指向该节点的右孩子
- rtag=1 rchild指向该结点的后继

![](王道二叉树(二).assets/20.png)



## 4.1、先序线索二叉树

![](王道二叉树(二).assets/15.png)



## 4.2、中序线索二叉树

![](王道二叉树(二).assets/16.png)







## 4.3、后序线索二叉树

![](王道二叉树(二).assets/105.png)





## 4.4、练习

画出以下二叉树对应的中序线索二叉树：

![](王道二叉树(二).assets/106.png)

先对这棵树进行中序遍历：H、D、I、B、E、A、F、C、G

![](王道二叉树(二).assets/107.png)

对于两侧悬空的空指针，我们可以增设一个头结点

ltag=0，lchild指向根节点

rtag=1，rchild指向遍历序列中最后一个结点

遍历序列中第一个结点的lc域和最后一个结点的rc域都指向头结点.这样会更方便

![](王道二叉树(二).assets/108.png)





# 3、线索二叉树找前驱/后继

## 3.1、中序线索二叉树找中序后继

例如：我们要在中序线索二叉树中找到指定结点 *p 的中序后继 next，next = p的右子树中最左下结点

![](王道二叉树(二).assets/22.png)



- 若 p -> rtag == 1, 说明右子树被线索化，那么右子树就是其中序后继，则 next = p -> rchild 
- 若 p-> rtag == 0,说明右子树未被线索化，右子树肯定是非空，则 p 必然有右孩子。
  - 因为是中序遍历，那么右孩子中第一个被中序遍历的结点必然是 p 的中序后继。
  - 假设 p 只有 1 个右孩子，并且这个右孩子只有一个结点，那么这个结点就是 p 的后继
  - 假设 p 右孩子有下一层，那么下一层最先被访问的结点(最左下结点)，就是 p 的后继
  - 所以中序后继 next = p的右子树中最左下结点

```c
// 找到以 P 为根的子树中,第一个被中序遍历的结点
ThreadNode *Firstnode(ThreadNode *p){
    // 循环找到最左下结点(不一定是叶结点)
    while(p->ltag == 0){
        p = p->lchild;
    }
    return p;
}

// 在中序线索二叉树中找到结点 p 的后继结点
ThreadNode *Nextnode(ThreadNode *p){
    // 右子树最左下结点(右子树当中第一个被遍历到的结点)
    if(p->rtag == 0){
        return Firstnode(p->rchild);
    }else{
        return p->rchild;		// rtag == 1 直接返回后继线索
    }
}
```

既然我们能遍历到结点的后继结点，那么我们就可以对中序线索二叉树进行遍历

```c
// 对中序线索二叉树进行中序遍历(利用线索实现的非递归算法) 
// 传入我们要遍历的树的根节点的指针T
void Inorder(ThreadNode *T){
    for(ThreadNode *p = Firstnode(T);p != NULL;p=Nextnode(p)){
        visit(p);
    }
}
```



## 3.2、中序线索二叉树找中序前驱

例如：我们要在中序线索二叉树中找到指定结点 *p 的中序前驱pre，pre= p的左子树中最右下结点

![](王道二叉树(二).assets/23.png)



- 若 p -> ltag == 1, 说明左子树被线索化，那么左子树就是其中序后继，则 pre = p -> lchild 

- 若 p-> ltag == 0,说明左子树未被线索化，那么左子树肯定非空，则 p 必然有左孩子。

  - 因为是中序遍历，那么左孩子中最后一个中序遍历的结点必然是 p 的中序前驱。

  - 假设 p 只有 1 个左孩子，并且这个左孩子只有一个结点，那么这个结点就是 p 的前驱
  - 假设 p 左孩子有下一层，那么下一层最后访问的结点(最右下结点)，就是 p 的前驱
  - 所以中序前驱 pre = p 的左子树中最右下结点

```c
// 找到以p为根的子树中,最后一个被中序遍历的结点
ThreadNode *Lastnode(ThreadNode *p){
    // 循环找到最右下结点(不一定是叶节点)
    while(p->rtag == 0){
        p = p->rchild;
        return p;
    }
}

// 在中序线索二叉树中找到结点p的前驱结点
ThreadNode *Prenode(ThreadNode *p){
    // 左子树中最右下结点
    if(p->ltag == 0){
        return Lastnode(p->lchild);
    }else{
        return p->lchild;			//ltag==1 直接返回前驱结点
    }
}
```

既然我们能遍历到结点的前驱结点，那么我们就可以对中序线索二叉树进行逆向中序遍历

```c
// 对中序线索二叉树进行逆向中序遍历
void RevInorder(ThreadNode *T){
    for(ThreadNode *p = Lstnode(T);p != NULL;p = Prenode(p){
        visit(p);
    })
}
```



## 3.3、先序线索二叉树找先序后继

![](王道二叉树(二).assets/24.png)



- 若 p -> rtag == 1, 说明右子树被线索化，那么右子树就是其先序后继，则 next= p -> rchild 

- 若 p-> rtag == 0,说明右子树未被线索化，那么右子树肯定非空，则 p 必然有右孩子。














# 4、树的存储结构

![](王道二叉树(二).assets/26.png)

## 4.1、树的逻辑结构回顾

树是 n(n≥0)个结点的有限集合，n=0时，称为空树，这是一种特殊情况。在任意一棵**非空树**中应满足：

1. 有且仅有一个特定的称为根的结点
2. 当 n>1 时，其余结点可分为 m(m>0) 个互不相交的有限集合 T~1~、T~2~、T~3~、...T~m~ ,其中每个集合本身又是一棵树，并且称为树结点的子树。

![](王道二叉树(二).assets/25.png)





## 4.2、双亲表示法(顺序存储)

![](王道二叉树(二).assets/27.png)

```c
#define MAX_TREE_SIZE 100 // 树中最多结点数
typedef struct{			  // 树的结点定义
    ElemType data;		  // 数据元素
    int parent;			  // 双亲位置域
}PTNode;
typedef struct{				// 树的类型定义
    PTNode nodes[MAX_TREE_SIZE]; // 双亲表示
    int n;					// 结点数
}PTree;
```





- 若我们要新增数据元素，无需按逻辑上的次序存储，只需要存储其父节点的数组下标即可

![](王道二叉树(二).assets/28.png)

- 若我们要删除G这个结点，有两种删除方法
  - 将G这个结点的双亲指针设为 -1
  - 将尾部数据移动，填充G处的 data 和 parent



## 4.3、孩子兄弟表示法(链式存储)🔥

左孩子右兄弟也用来表示树与二叉树之间的转换：

- 树的先根遍历序列与这棵树相应二叉树的先序序列相同
- 树的后根遍历序列与这棵树相应二叉树的中序序列相同

![](王道二叉树(二).assets/29.png)



- 左指针指向第一个孩子结点，右指针指向兄弟结点

- A 是根节点，A的第一个孩子是B，所以A左连接B，B的兄弟结点是C，所以让B右连接C，D是C的兄弟结点，所以让C右连接D。
- B的第一个孩子是E，所以让B左连接E，E的兄弟结点是F，所以让E右连接F。
- E的第一个孩子是K，所以让E左连接K
- C的第一个孩子是G，所以让C左连接G
- D的第一个孩子是H，所以让D左连接H，I、J都是是H的兄弟结点，所以让H右连接I、J

![](王道二叉树(二).assets/30.png)



- A是根节点，左边的B是第一个孩子，B的右边C、F、L都是B的兄弟

- D连在B的左边，所以D是B的第一个孩子，H是D的兄弟

- G连在D的左边，所以G是D的孩子

- E连在C的左边，所以E是C的第一个孩子，I连在E的左边，所以I是E的第一个孩子，J连在E的右边，所以J是E的兄弟

  



## 4.4、森林和二叉树的转换

> 森林转化为二叉树

![](王道二叉树(二).assets/31.png)

- B、C、D 是兄弟结点，各个树的根节点视为兄弟关系，所以将C、D右连接B
- E是B的第一个孩子，所以将E左连接B，F是E的兄弟结点，所以将F右连接E
- K是E的第一个孩子，所以将K左连接E，L是K的兄弟结点，所以将L右连接L





> 二叉树转化为森林

![](王道二叉树(二).assets/32.png)

- A、C、F、L是兄弟结点，分别为二叉树的跟结点
- A的左边连接了B，所以B是A的第一个孩子，B的左边连接了D，所以D是B的第一个孩子，D的左边连接了G，所以G是D的第一个孩子，D的右边连接了H，所以D和H是兄弟结点
- C的左边连接了E，所以E是C的第一个孩子，E的左边连接了I，所以I是E的第一个孩子，E的右边连接了J，所以E和J是兄弟结点。

- F的左边连了K，所以K是F的第一个孩子



## 4.5、小结

![](王道二叉树(二).assets/33.png)



# 5、树的存储(王卓)

## 5.1、双亲表示法

实现：定义结构数组，存放树的结点，每个结点含两个域

- 数据域：存放结点本身信息
- 双亲域：指示本结点的双亲结点在数组中的位置

如下图：R为根节点，双亲域表示了其双亲结点，例如A、B、C双亲域为0，则其双亲为R结点

![](王道二叉树(二).assets/93.png)

**特点：找双亲容易，找孩子难。**

![](王道二叉树(二).assets/94.png)

```c
// 结点类型
typedef struct PTNode{
    TElemType data;
    int parent; 	// 双亲位置域
}PTNode;

// 树结构
#define MAX_TREE_SIZE 100 
typedef struct{
    PTNode nodes[MAX_TREE_SIZE];
    int r,n; // r代表根节点的位置,n代表结点个数
}PTree;
```





## 5.2、孩子链表

把每个结点的孩子结点排列起来，看成是一个线性表，用单链表存储。则n个结点有n个孩子链表(叶子的孩子链表为空表)。而n个头指针又组成一个线性表，用顺序表(含n个元素的结构数组)存储。

![](王道二叉树(二).assets/95.png)



---

孩子结点结构：

![](王道二叉树(二).assets/96.png)

```c
//孩子结点结构
typedef struct CTNode{
    int child;
    struct CTNode *next;
}*ChildPtr;
```

![](王道二叉树(二).assets/97.png)

```c
//双亲结点结构
typedef struct{
    TElemType data;
    ChildPtr firstchild;	//孩子链表头指针
}CTBox;

// 树结构
typedef struct{
    CTBox nodes[MAX_TREE_SIZE];
    int n,r; //结点数和根节点的位置
}CTree;
```

**孩子链表特点：找孩子容易，找双亲难**

我们可以多一个域，存储双亲结点的数组下标：这叫做带双亲的孩子链表。

![](王道二叉树(二).assets/98.png)



## 5.3、孩子兄弟表示法

实现：用二叉链表作树的存储结构，链表中的每个结点的两个指针域分别指向其**第一个孩子结点**和**下一个兄弟结点**。

```c
typedef struct CSNode{
    ElemType data;
    struct CSNode *firstchild,*nextsibling;
}CSNode,*CSTree;
```

![](王道二叉树(二).assets/99.png)

R结点是根节点，左孩子指向其第一个孩子结点A，右孩子指向兄弟结点为空。

A结点左孩子指向其第一个孩子D，右孩子指向兄弟结点为B。

B结点左孩子指向其第一个孩子为空，右孩子指向其兄弟结点C

D结点左孩子指向其第一个孩子为空，右孩子指向其兄弟结点E

E结点左孩子指向其第一个孩子为空，右孩子指向其下一个兄弟结点为空。

...

在这个二叉链表中，如果我们要找孩子结点：

例如我们要找根节点的孩子，从根节点出发，左孩子为其第一个孩子，左孩子的右指针为其第二个孩子，第二个孩子的右指针为其第三个孩子。例如，R的左孩子A为其第一个孩子,A的右指针B为其兄弟结点是R的第二个孩子，B的右指针C为其兄弟结点是R的第三个孩子。





## 5.4、森林和二叉树的转换(王卓)

### 5.4.1、森林转换成二叉树

森林转换成二叉树(二叉树与多棵树之间的关系)

1. 将各棵树分别转换成二叉树
2. 将每棵树的根结点用线相连
3. 以第一课树根结点为二叉树的根，再以根结点为轴心，顺时针旋转，构成二叉树型结构

> 森林变二叉树，树变二叉根相连

![](王道二叉树(二).assets/100.png)



### 5.4.2、二叉树转换成森林

1. 抹线：将二叉树中**根节点**与其右孩子连线，及沿右分支搜索到的所有右孩子间连线全部抹掉，使之变成孤立的二叉树
2. 还原：将孤立的二叉树还原成树

> 去掉全部右孩线，孤立二叉再还原



![](王道二叉树(二).assets/101.png)





## 5.5、树和森林的遍历

### 5.5.1、树的遍历(三种方式)

1. 先序遍历：若树不空，则先访问根结点，然后依次先序遍历各棵子树
2. 后序遍历：若树不空，则先依次后根遍历各棵子树，然后访问根结点
3. 层次遍历：若树不空，则自上而下自左向右访问树中每个结点。

![](王道二叉树(二).assets/102.png)







### 5.5.2、森林的遍历

将森林看作由三部分构成：

![](王道二叉树(二).assets/103.png)

1. 森林中第一棵树的根结点
2. 森林中第一棵树的子树森林
3. 森林中其他树构成的森林

---

- 先序遍历

若森林不空，则：

1. 访问森林中第一棵树的根结点
2. 先序遍历森林中第一棵树的子树森林
3. 先序遍历森林外(除第一棵树之外)，其余树构成的森林

> **即依次从左至右对森林中的每一棵树进行先根遍历。**



- 中序遍历

若森林不空，则：

1. 中序遍历森林中第一棵树的子树森林
2. 访问森林中第一棵树的根结点
3. 中序遍历森林中(除第一棵树之外)其余树构成的森林

> **即依次从左至右对森林中的每一棵树进行后根遍历。**

例题：

![](王道二叉树(二).assets/104.png)



先序遍历：A B C D E F G H I J 

中序遍历：B C D A F E H J I G







# 5、树、森林的遍历



![](王道二叉树(二).assets/34.png)





## 5.1、树的先根遍历

先根遍历：若树非空，先访问根节点，再依次对每棵子树进行先根遍历。

![](王道二叉树(二).assets/35.png)

```c
// 树的先根遍历
void PreOrder(TreeNode *R){
    if(R!=NULL){
        visit(R); // 访问根结点
        while(R还有下一个子树T){
            PreOrder(T);			// 先根遍历下一棵子树
        }
    }
}
```



## 5.2、树的后根遍历

- 后根遍历：若树非空，先依次对每棵子树进行后根遍历，最后再访问根结点。
- 树的后根遍历也叫做深度优先遍历。

![](王道二叉树(二).assets/36.png)









## 5.3、树的层次遍历

树的层次遍历也叫做广度优先遍历。

![](王道二叉树(二).assets/37.png)





## 5.4、森林的先序遍历

先序遍历森林：

- 若森林为空，则按如下规则进行遍历
- 访问森林中第一棵树的根结点，先序遍历第一棵树中根结点的子树森林，先序遍历除去第一棵树之后剩余的树构成的森林。(效果等同于依次对各个树进行先根遍历)

![](王道二叉树(二).assets/38.png)

或者将其转化为对应的二叉树，先序遍历森林效果等同于依次对二叉树的先序遍历。

![](王道二叉树(二).assets/39.png)



> 森林的先序遍历序列与这棵树相应二叉树的先序序列相同



## 5.5、森林的中序遍历

![](王道二叉树(二).assets/40.png)

另一种方法就是将其转换成与之对应的二叉树，中序遍历森林效果等同于依次对二叉树的中序遍历。

![](王道二叉树(二).assets/41.png)



> 森林的中序遍历序列与这棵树相应二叉树的中序序列相同

## 5.5、小结

![](王道二叉树(二).assets/42.png)























# 6、二叉排序树

![](王道二叉树(二).assets/43.png)

## 6.1、二叉排序树的定义

二叉排序树，又称二叉查找树(BST,Binary Search Tree),一棵二叉树或者是空二叉树，或者是具有如下性质的二叉树：

- 左子树上所有结点的关键字均小于根结点的关键字
- 右子树上所有结点的关键字均大于根结点的关键字
- 左子树和右子树又各是一棵二叉排序树

![](王道二叉树(二).assets/44.png)

> 左子树的结点值<根节点值<右子树结点值



## 6.2、二叉排序树的查找

若树非空目标值与根节点的值比较，若相等，则查找成功。若小于根节点，则在左子树上查找，否则在右子树上查找。

![](王道二叉树(二).assets/45.png)



```c
// 二叉排序树结点
typedef struct BSTNode{
    int key;
    struct BSTNode *lchild,*rchild;
}BSTNode,*BSTree;

// 在二叉排序树中查找值为key的结点(传入根节点指针和值)
BSTNode *BST_Search(BSTree T,int key){
    while(T!=NULL&&key!=T->key){		// 若树空或等于根结点,则结束循环
        if(key<T->key){
            T=T->lchild;				// 小于,则在左子树上查找
        }else{
            T=T->rchild;				// 大于,则在右子树上查找
        }
        return T;
    }
}
```

当然我们也可以递归实现

```c
// 在二叉排序树中查找值为key的结点(递归实现)
BSTNode *BSTSearch(BSTree T,int key){
    if(T==NULL){
        return NULL; // 查找失败
    }
    if(key==T->key){
        return T;	// 查找成功
    }else if(key<T->key){
        return BSTSearch(T->lchild,key);	// 在左子树中找
    }else{
        return BSTSearch(T->rchild,key);	// 在右子树中找
    }
}
```

两者不同点在于最坏空间复杂度不同

![](王道二叉树(二).assets/46.png)





## 6.3、二叉排序树的插入

若原二叉排序树为空，则直接插入结点；否则，若关键字k小于根节点值，则插入到左子树，若关键字k大于根节点值，则插入到右子树。

> 注意：新插入的结点一定是叶子结点

```c
// 在二叉排序树插入关键字为k的新结点(递归实现)
int BST_Insert(BSTree &L,int k){
    if(T==NULL){				// 原树为空,新插入的结点为根结点
        T=(BSTree)malloc(sizeof(BSTNode));
        T->key=k;
        T->lchild=T->rchild=NULL;
        return 1;		// 返回1,插入成功
    }else if(k==T->key){		// 树中存在相同关键字的结点,插入失败
		return 0;        
    }else if(k<T->key){			// 插入到T的左子树
        return BST_Insert(T->lchild,k);
    }else{						// 插入到T的右子树
        return BST_Insert(T->rchild,k);
    }
}
```









## 6.4、二叉排序树的构造

![](王道二叉树(二).assets/47.png)



```c
// 按照str[]中的关键字序列建议二叉排序树
void Create_BST(BSTree &T,int str[],int n){
    T=NULL;  //初始时T为空树
    int i = 0;
    while(i<n){  // 依次将每个关键字插入到二叉排序树中
        BST_Insert(T,str[i]);
        i++;
    }
}
```

![](王道二叉树(二).assets/48.png)

> 不同的关键字序列可能得到同款二叉排序树，也可能得到不同款二叉排序树







## 6.5、二叉排序树的删除

先搜索到目标结点：

1. 若被删除结点z是叶子结点，则直接删除，不会破坏二叉排序树的性质
2. 若结点z只有一棵左子树或右子树，则让z的子树成为z父结点的子树，替代z的位置

![](王道二叉树(二).assets/49.png)

- 如13这个结点，它只有左子树，我们删除 13，然后让其子树顶上。这样就依然可以保证二叉排序树的性质

![](王道二叉树(二).assets/50.png)



3. 若结点z有左、右两棵子树，则令z的直接后继(或直接前驱)替代z，然后从二叉排序树中删去这个直接后继(或直接前驱)，这样就转换成了第一或第二种情况
   - 删除有两种方式，第一种我们可以使用结点z的直接后继替代z(也就是z结点右子树中第一个被中序遍历的结点(**或者说右子树中值最小的结点**))`{z的后继:z的右子树中最左下结点(该结点一定没有左子树)}`
   - 第二种我们可以使用结点z的直接前驱替代z(也就是z结点左子树中最后一个被中序遍历的结点(**或者说左子树中值最大的结点**))`{z的前驱:z的左子树中最右下结点（该结点一定没有右子树}`

![](王道二叉树(二).assets/51.png)

例如，我们要删除值为50的结点，我们采用第一种方法，找其右子树中值最小的结点60替代50，此时原来50的位置就变成了60，接着再删除60这个结点，因为60结点只有右子树，我们删除60结点，让其子树顶上，如下：

![](王道二叉树(二).assets/52.png)

若我们采用第二种方法，找其左子树中值最大的结点替代，如图：

![](王道二叉树(二).assets/53.png)





## 6.6、查找效率分析

二叉排序树查找成功的平均查找长度ASL:

- **最好情况：n个结点的二叉排序树最小高度为 h =   ⌊log~2~n⌋+1，平均查找长度为 = O(log~2~n)**
- **最坏情况：每个结点只有一个分支，树高h = 结点数n，平均查找长度 = O(n)** 

![](王道二叉树(二).assets/54.png)



查找失败的平均查找长度ASL

![](王道二叉树(二).assets/55.png)







## 6.7、小结

![](王道二叉树(二).assets/56.png)

# 7、平衡二叉树

![](王道二叉树(二).assets/57.png)

平衡二叉树(Balanced Binary Tree)，简称平衡树(AVL数)：树上任一结点的左子树和右子树的高度之差不超过1。

**结点的平衡因子** = 左子树高度 - 右子树高度

一棵平衡二叉树或者是空树，或者是具有下列性质的二叉排序树：

1. 左子树与右子树的高度之差的绝对值小于等于1
2. 左子树和右子树也是平衡二叉树

![](王道二叉树(二).assets/58.png)

- 平衡二叉树结点的平衡因子的值只可能是 -1、0或1
- 只要有任一结点的平衡因子绝对值大于1，就不是平衡二叉树。

```c
// 平衡二叉树结点
typedef struct AVLNode{
    int key;			// 数据域
    int balance;		// 平衡因子
    struct AVLNode *lchild,*rchild;
}AVLNode,*AVLTree;	
```





## 7.1、平衡二叉树的插入

在二叉排序树种插入新结点后，如何保持平衡？

![](王道二叉树(二).assets/59.png)



例如上图我们插入结点 67 后，右边的结点受到了不平衡的影响，我们需要进行调整，调整的对象是从插入点往回找到第一个不平衡的结点，调整以该结点为根的子树。

![](王道二叉树(二).assets/60.png)

最小不平衡子树：例如上图的 66 和 70 结点都不平衡，我们要找所含结点最小的，70有3个结点，66有5个结点，所以我们将70为根节点组成的子树称为最小不平衡子树。





## 7.2、调整最小不平衡子树

![](王道二叉树(二).assets/61.png)





### 7.2.1、LL

LL：在A的左孩子的左子树中插入导致不平衡

我们调整至平衡，还要使其保持二叉排序树特性。

![](王道二叉树(二).assets/62.png)

这里个人感觉讲的并不易于理解，推荐听一下青岛大学王卓老师的这块比较好理解。



### 7.2.2、RR

![](王道二叉树(二).assets/63.png)



### 7.2.3、代码思路

![](王道二叉树(二).assets/64.png)

### 7.2.4、LR

![](王道二叉树(二).assets/65.png)



![](王道二叉树(二).assets/66.png)



![](王道二叉树(二).assets/67.png)

### 7.2.5、RL

![](王道二叉树(二).assets/68.png)





![](王道二叉树(二).assets/69.png)

![](王道二叉树(二).assets/70.png)





### 7.2.6、小结

![](王道二叉树(二).assets/71.png)









## 7.3、王卓平衡二叉树的调整

![](王道二叉树(二).assets/72.png)



- LL型：C<B<A,所以我们调整之后也得保持C<B<A
- LR型：B<C<A,所以我们调整之后也得保持B<C<A



### 7.3.1、LL型



![](王道二叉树(二).assets/73.png)

- B结点带左子树α一起上升
- A结点成为B的右孩子
- 原来B结点的右子树β作为A的左子树









### 7.3.2、RR型

![](王道二叉树(二).assets/74.png)

- B结点带右子树β一起上升
- A结点成为B的左孩子
- 原来B结点的左子树α作为A的右子树

例如：

![](王道二叉树(二).assets/75.png)





### 7.3.3、LR型

![](王道二叉树(二).assets/76.png)



- C结点穿过A、B结点上升
- B结点成为C的左孩子,A结点成为C的右孩子
- 原来C结点的左子树β作为B的右子树，原来C结点的右子树γ作为A的左子树

例如：

![](王道二叉树(二).assets/77.png)









### 7.3.4、RL型

![](王道二叉树(二).assets/78.png)







### 7.3.5、例题

给出关键字序列(16,3,7,11,9,26,18,14,15)，给出构造一棵 AVL 树的步骤。

- 插入一个结点计算平衡因子

![](王道二叉树(二).assets/89.png)

- 注意：我们如果发现有两棵树都不平衡，我们要调整最小的失衡子树

  例如下图中，以7为根节点的左子树高度为1，右子树高度为3，则平衡因子为2失衡；以16为根节点的左子树高度为2，右子树高度为0，平衡因子为2失衡，我们要调整的是最小的失衡子树，所以调整以16为根节点的失衡子树。

![](王道二叉树(二).assets/90.png)



![](王道二叉树(二).assets/91.png)



![](王道二叉树(二).assets/92.png)





# 8、哈夫曼树

![](王道二叉树(二).assets/79.png)







## 8.1、带权路径长度

![](王道二叉树(二).assets/80.png)

结点的权：有某种现实含义的数值(如：表示结点的重要性等)

结点的带权路径长度：**从树的根到该结点的路径长度(经过的边数)与该结点上权值的乘积。**

- 例如上图结点为3的带权路径长度 = 3 × 3 = 9

树的带权路径长度：**树中所有叶结点的带权路径长度之和**



## 8.2、哈夫曼树的定义

![](王道二叉树(二).assets/81.png)

哈夫曼树：**带权路径长度最小的二叉树称为哈夫曼树**。







## 8.3、哈夫曼树的构造(王道)

给定 n 个权值分别为W~1~，W~2~，W~3~，W~4~...W~n~ 的结点，构造哈夫曼树的算法描述如下：

1. 将这n个结点分别作为n棵仅含一个结点的二叉树，构成森林F
2. 构造一个新结点，从F中选取两棵根节点权值最小的树作为新结点的左、右子树，并且将新结点的权值置为左、右子树上根节点的权值之和
3. 从F中删除刚才选出的两棵树，同时将新得到的树加入F中
4. 重复步骤2和3，直到F中只剩下一棵树为止



这里的构造可能对于初学者不好理解，推荐听青岛大学王卓老师的课

## 8.4、哈夫曼树的构造(王卓)

路径：**从树中的一个结点到另一个结点之间的分支构成这两个结点间的路径**

结点的路径长度：**两结点间路径上的分支数**



![](王道二叉树(二).assets/82.png)

树的路径长度：从树根到每一个结点的路径长度之和。记作TL

![](王道二叉树(二).assets/83.png)

> 结点数目相同的二叉树中，完全二叉树是路径长度最短的二叉树。

权：将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。

结点的带权路径长度：从**根**结点到该结点之间的**路径长度**与该节点的权的**乘积**。

树的带权路径长度：树中所有**叶子结点**的**带权路径长度之和**。记作WPL(Weighted Path Length)

![](王道二叉树(二).assets/84.png)

哈夫曼树：最优树(带权路径长度(WPL)最短的树)

注意："带权路径长度最短"是在"度相同"的树中比较而得的结果，因此有最优二叉树、最优三叉树之称等等。

哈夫曼树：最优二叉树(带权路径长度(WPL)最短的二叉树)

---

构造哈夫曼树的方法：

1. 根据n个给定的权值{W~1~,W~2~,W~3~,...W~n~}构成n棵二叉树的森林F={T~1~,T~2~,...T~n~},其中T~i~只有一个带权为W~i~的根节点
2. 在F中选取两棵根节点的权值最小的树作为左右子树，构造一棵新的二叉树，且设置新的二叉树的根节点的权值为其左右子树上根节点的权值之和。
3. 在F中删除这两棵树，同时将新的到的二叉树加入森林中。
4. 重复2和3，直到森林中只有一棵树为止，这颗树即为哈夫曼树。

> 王卓老师的口诀：1.构造森林全是根，2.选用两小造新树，3.删除两小添新人，4.重复2、3剩单根

![](王道二叉树(二).assets/85.png)

1. 构造森林全是根。有几个结点就有几个根节点，从而组成森林。

   - 例如上方有4个结点，则将其都作为根节点组成森林。

2. 选择两个权值最小的结点，将其权值加和，得到的权值为父结点，两个权值最小的结点为左右子树。

   - 例如上方权值最下的两个结点为 2 和 4，将其权值加和为6，则 6 为父结点， 2 和 4 为左右子树。

3. 删除刚才选择的那两个权值最小的结点，将剩余结点与第二步得到的父结点排成一排结成森林。

   - 删除2和4结点，将 7、5、6三个结点作为根组成森林

4. 继续选择两个权值最小的结点，将其权值加和，得到的权值为父结点，两个权值最小的结点为左右子树。

   - 继续选择 5、6 两个结点，权值加和为11，则 11 为父结点，5、6为左右子树。

   

> 1. 每个初始结点最终都成为叶节点，且**权值越小的结点到根结点的路径长度越大**
> 2. 包含n个叶子结点的哈夫曼树中共有 2n-1 个结点。(n个结点，两两合并，总共合并n-1次，产生n-1个新结点)
> 2. 哈夫曼树的结点的度为0或2，没有度为1的结点。
> 3. 度为0的结点是n个，度为2的结点是 n-1 个
> 3. 哈夫曼树并不唯一，但带权路径长度(WPL)必然相同且为最优











## 8.5、哈夫曼树的应用

### 8.5.0、哈夫曼编码

**前缀编码**：若没有一个编码是另一个编码的前缀。例如：

- C：0
- A：10
- B：111
- D：110

---

- C：0
- A：1
- B：111
- D：110

A的编码是1，B、D的编码也有前缀是1，这种编码就是非前缀编码



### 8.5.1、哈夫曼编码(王卓)

1. 统计字符集每个字符在电文中出现的平均概率(概率越大，要求编码越短)
2. 利用哈夫曼树的特点：权越大的叶子离根越近，将每个字符的概率值作为权值，构造哈夫曼树。则概率越大的结点，路径越短。
3. 在哈夫曼树的每个分支上标上0或1，结点的左分支标0，右分支标1，把从根到每个叶子的路径上的标号连接起来，作为该叶子代表的字符的编码。

例题：

![](王道二叉树(二).assets/86.png)

1. 构造哈夫曼树
2. 左分支标0，右分支标1，把从根到每个叶子的路径上的标号连接起来，作为该叶子代表的字符的编码。

![](王道二叉树(二).assets/87.png)









## 8.6、小结

![](王道二叉树(二).assets/88.png)







# 9、并查集

集合：将各个元素划分为若干个**互不相交**的子集，森林就是若干课**互不相交**的树的集合。所以我们用互不相交的树，表示多个"集合"。

![](王道二叉树(二).assets/109.png)

如何查到一个元素到底属于哪一个集合？

- **从指定元素出发，向上遍历找到根结点**

如何判断两个元素是否属于同一个集合？

- **分别查到两个元素的根，判断根节点是否相同**

如何把两个集合并为一个集合？

- **让一棵树成为另一棵树的子树即可**

![](王道二叉树(二).assets/110.png)



如上图，数据元素A-M对应数据下标0-12，用一个数组 S[] 表示集合关系。

- 数组中存放对应元素**父节点的数组下标**，根节点对应的下标是-1

集合的两个基本操作：并和查

- Find ： 查操作，确定一个指定元素所属集合
- Union：并操作，将两个不相交的集合合并为一个



## 9.1、并查集初始化

![](王道二叉树(二).assets/111.png)

- 并查集初始化：**将数组的值设为-1**









## 9.2、并、查

![](王道二叉树(二).assets/112.png)



- 查：一直向上找，而数组中保存了父节点的下标，所以只要数组下标 < 0，则说明找到了根
  - 例如我们要找L的集合，L的父节点为4，4是E，E的父节点为1，1是B，B的父节点是0，0是A，A是根，则L是A下的子集
- 并：把一个树放在另一个树的根节点下。
  - 例如将图中前两个数合并，将C的父节点设为A



## 9.3、时间复杂度分析

![](王道二叉树(二).assets/113.png)

- 若结点数为n，查Find最坏时间复杂度为 O(n)
- 优化：但每次合并操作构建树的时候，尽可能让树不长高
  1. **用根节点的绝对值表示树的节点总数**
  2. **合并操作，让小树合并到大树**

![](王道二叉树(二).assets/114.png)

如上图： A总共有6个节点，所以A的值是 -6， 用根节点的绝对值表示树的节点总数6。B总共有2个结点，所以B的值是-2。节点数更小的就是小树。小树合并大树，让小树的根节点的值指向大树，也就是把C的数组值变为0，将A的值改为-8

![](王道二叉树(二).assets/115.png)



- 优化之后，可以使得构造的树不超过 ⌊log~2~n⌋+1 ，这样可以保证查Find操作的最坏时间复杂度为 O(log~2~n)











## 9.4、并查集的进一步优化

 



























































