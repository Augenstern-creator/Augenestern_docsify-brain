# 1、查找

- 查找：在数据集合中寻找满足某种条件的数据元素的过程称为查找

- 查找表(查找结构)：⽤于查找的数据集合称为查找表，它由同⼀类型的数据元素（或记录）组成

- 关键字：数据元素中唯⼀标识该元素的某个数据项的值，使⽤基于关键字的查找，查找结果应该是唯⼀的。

- **静态查找表**：仅关注**查找速度**即可

- **动态查找表**：除了查找速度，也要关注插/删操作是否方便实现。

## 1.1、查找算法的评价指标

- 查找长度：**在查找算法中，需要对比关键字的次数称为查找长度**

- 平均查找长度(ASL)：**所有查找过程中进行关键字的比较次数的平均值**



## 1.2、顺序查找

顺序查找：又叫"线性查找"，通常用于线性表。

- 算法思想：**从头到脚挨个找**

```c
typedef struct{				// 查找表的数据结构(顺序表)
    ElemType *elem;			// 动态数组基址
    int TableLen;			// 表的长度
}SSTable;
// 顺序查找
int Search_Seq(SSTable ST,ElemType key){
    int i;
    for(i=0;i<ST.TableLen && ST.elem[i]!=key;++i){
        // 查找成功,则返回元素下标;查找失败,则返回-1
        return i==ST.TableLen ? -1 : i;
    }
}
```

例如我们要查找43：依次向后查找，查找成功，则返回元素下标

![](王道查找(一).assets/1.png)

![](王道查找(一).assets/2.png)

王道书上的方法：把0号位置空出来，实际的数据从1位置开始放，当我们要查找某一个关键字的时候，会把这个关键字放到0号位置，然后指针从最后一个位置向前扫描。

```c
typedef struct{				// 查找表的数据结构(顺序表)
    ElemType *elem;			// 动态数组基址
    int TableLen;			// 表的长度
}SSTable;
// 顺序查找
int Search_Seq(SSTable ST,ElemType key){
    ST.elem[0]=key;			// 哨兵,0号位置存哨兵
    int i;
    for(i=ST.TableLen;ST.elem[i]!=key;--i){		// 从后向前找
        // 查找成功,则返回元素下标;查找失败,则返回0
        return i;
    }
}
```

![](王道查找(一).assets/3.png)

当我们要查找某一个关键字时，会把关键字放到0号位置。让指针从最后一个位置向前扫描，查找成功，返回下标

![](王道查找(一).assets/4.png)

查找失败：指针所指向的值等于要查找的值，会导致跳出循环，return 0，查找失败

- 优点：**无需判断是否越界，效率更高。**

### 1.2.1、顺序查找效率分析

对于带哨兵的情况，我们是从后向前扫描：有n个关键字，假设要找任何一个关键字的概率都是相同的都是1/n

- 如果我们查找的元素恰好是最后一个元素，那么我们只需要对比1次关键字：1×(1/n)

- 如果我们查找的元素恰好是倒数第二个元素，那么我们只需要对比2次关键字：2×(1/n)

- **查找成功**：对于一个长度为n的查找表，我们要找其中任何一个元素的概率都是n/1，如果我们查找的元素恰好是最后一个元素，那么只需要对比关键字1次，如果我们查找的元素恰好是倒数第二个元素，那么只需要对比关键字2次....总共有n个元素，如果我们查找的元素恰好是倒数第n个元素，则需要对比关键字n次

- $$
  ASL_{成功} = \frac{1+2+3+....+n}{n} = \frac{n+1}{2} \\
  
  \\
  ASL_{失败} = n+1
  $$

- **查找失败**：指针从n移动到0进行对比，共对比n+1次关键字





### 1.2.2、顺序查找的优化(对有序表)

若在查找之前就已经知道表是关键字有序的，则查找失败时可以不用在比较到表的另一端就能返回查找失败的信息，从而降低顺序查找失败的平均查找长度。

如下图：比如我们要找关键字21，表是递增排列，如果采用从前向后扫描，当扫描到29的时候，由于29>21，我们就知道此表中无21关键字了

![](王道查找(一).assets/6.png)

如上图：是查找判定树，我们要找的是21关键字，我们从7开始，21>7，所以向下一个关键字走，21>13，继续向下走，21>19，继续向下走，21<29，查找失败。**显然若这个有序表有n个元素，总共有n+1种查找失败的情况**。

![](王道查找(一).assets/7.png)

结论：

- **一个成功结点的查找长度 = 自身所在层数**
- **一个失败结点的查找长度 = 其父节点所在层数**

- 圆形结点称为成功结点，矩形结点称为失败结点





### 1.2.3、顺序查找的优化(被查概率不相等)

![](王道查找(一).assets/8.png)

如上图，若各个关键字被查找的概率不相同，我们可以将被查找概率更大的放在靠前的位置，这么做可以使得当我们在查找成功的情况下平均查找长度能更小。

- **这种排列方式又会变成乱序，对于查找成功很友好，对于查找失败仍旧是一夜回到解放前。**

### 1.2.4、小结

![](王道查找(一).assets/9.png)





## 1.3、折半查找🔥

折半查找：又称"二分查找",仅适用于**有序**的**顺序表**。

- **有序**：顺序表中的元素要么是递增要么是递减排放
- **顺序表**：用数组存放

![](王道查找(一).assets/10.png)



例如我们要查找33：

1. 首先让 low 指向第一个元素，high 指向最后一个元素(**用两个指针指向区间范围**)
2. 计算出 mid=(low+high)/2 = (0+10)/2 = 5，则说明我们第一个对比的关键字为 29
3. 33>29，则说明只可能在右边区域(**排除左边区域**)

![](王道查找(一).assets/11.png)

4. 然后将 low 指向 mid +1 的位置（如上图，之前mid指向5，所以 low 此时指向6）

![](王道查找(一).assets/12.png)



5. 继续计算 mid=(low+high)/2 = (6+10)/2 = 8,则说明我们要对比的关键字为37

6. 33<37，说明在左边区域

![](王道查找(一).assets/13.png)

7. 将high指针指向 mid-1 的位置(之前mid指向8，则此时high指向7)
8. 继续计算 mid=(low+high)/2 = (6+7)/2 = 6（**直接舍去小数点后**），则说明我们要对比的关键字为32

![](王道查找(一).assets/14.png)

9. 33>32，说明只可能在右边区域
10. 则让low指向mid的右边位置，让low指向7，此时计算 mid = (7+7)/2=7
11. 33 == 33，查找成功

![](王道查找(一).assets/15.png)

---

我们再来看一个例子：查找关键字12

![](王道查找(一).assets/16.png)

1. mid = (0+10)/2 = 5，29>12，则只可能在左边区域
2. 让 high 指向 mid 左边位置，mid = (0+4)/2 = 2,13>12,只可能在左边区域

![](王道查找(一).assets/17.png)

3. high 指向 mid 左边位置，mid = (0+1)/2 = 0,12>7,只可能在右边区域

![](王道查找(一).assets/18.png)



4. low 指向mid 右边位置，mid = (1+1)/2 = 1，12 != 10，查找失败





### 1.3.1、折半查找的实现

下方代码是基于**顺序表是升序排列**的条件来写的

```c
typedef struct{		//查找表的数据结构(顺序表)
    ElemType *elem;	//动态数组基址
    int TableLen;	//表的长度
}SSTable;

// 折半查找
int Binary_Search(SSTable L,ElemType key){
    int low = 0,high = L.TableLen -1,mid;
    while(low<=high){
        mid=(low+high)/2;		// 取中间位置
        if(L.elem[mid]==key){
            return mid;			// 查找成功则返回所在位置
        }else if(L.elem[mid]>key){
            high=mid-1;			// 从前半部分继续查找
        }else{
            low=mid+1;			// 从后半部分继续查找
        }
    }
}
```



### 1.3.2、查找效率分析

![](王道查找(一).assets/19.png)

如上图，

- 查找成功：第1层对比一次，第2层对比两次，第3层对比4次，第4层对比4次。
  - ASL~成功~ = (1×1+2×2+3×4+4×4)/11 = 3
- 查找失败：第3层对比4次，第4层对比8次
  - ASL~失败~ = (3×4+4×8)/12 = 11/3

- **查找成功的查找长度为从根节点到目的节点的路径上的节点数**
- **查找不成功时的查找长度为从根节点到对应失败节点的父节点的路径上的节点数**
- **每个节点值均大于其左结点值，且均小于其右节点值**







### 1.3.3、折半查找判定树的构造

![](王道查找(一).assets/20.png)

- 如果当前low和high之间有奇数个元素，则mid分隔后，左右两部分元素个数相等
- 如果当前low和high之间有偶数个元素，则mid分隔后，左半部分比右半部分少一个元素

![](王道查找(一).assets/21.png)

> 折半查找的判定树中，若mid=(low+high)/2，则对于任何一个结点，必有 `右子树结点数-左子树结点数=0或1`
>
> - 左右子树结点相同，或者左子树比右子树少一个结点

![](王道查找(一).assets/39.png)

![](王道查找(一).assets/22.png)

- **折半查找的判定树一定是平衡二叉树**(左右子树深度之差不超过1)

- **折半查找的判定树中，只有最下面一层是不满的，因此元素个数为 n 时树高 h**
  $$
  树高 h = ⌈ log_2(n +1)⌉   \\
  \\
  和计算完全二叉树高度计算方法相同(这里折半查找判定树不包括失败结点,若包含失败结点，则树高 = h+1
  $$
  

![](王道查找(一).assets/23.png)

- 折半查找判定树树节点的关键字：**左<中<右**，满足二叉排序树，所以
  - ==折半查找判定树是平衡二叉排序树==
- **对于有n个成功结点的判定树，失败结点个数为n+1**
  - 其实在连接失败结点时，是连在了成功结点的空链域，对于有n个结点的二叉树，总共会有n+1个空链域
  - 失败结点的数量 = 空链域的数量 = n+1



![](王道查找(一).assets/24.png)



![](王道查找(一).assets/25.png)



### 1.3.4、查找效率

- **折半查找的平均查找长度ASL ≤ 树高h(不包含失败结点的树高)** 

- **折半查找的时间复杂度 = O(log~2~n)**

- **查找成功的查找长度为从根节点到目的节点的路径上的节点数**
- **查找不成功时的查找长度为从根节点到对应失败节点的父节点的路径上的节点数**
- **每个节点值均大于其左结点值，且均小于其右节点值**

![](王道查找(一).assets/26.png)





### 1.3.5、小结

![](王道查找(一).assets/27.png)





### 1.3.6、扩展

- 折半查找的时间复杂度 = O(log~2~n)，顺序查找的时间复杂度 =O(n)
- **只能说折半查找的速度一般情况下比顺序查找更快，不能说任何情况下都更优秀**。

![](王道查找(一).assets/28.png)

我们之前是让 mid 的向下取整，如果向上取整：

- 如果当前low和high之间有奇数个元素，则mid分隔后，左右两部分元素个数相等
- 如果当前low和high之间有偶数个元素，则mid分隔后，左半部分比右半部分**多**一个元素

![](王道查找(一).assets/29.png)



![](王道查找(一).assets/30.png)





## 1.4、分块查找

多半选择题，很少考代码。

如下图：将元素分成一个一个的小区间，第一个区间内都是≤10的元素，第一个区间内都是≤20的元素...

- 可以查找表建立上一级的索引表，索引表中保存每个分块的**最大关键字**和**分块的存储区间(数组下标)**
- ==块内无序，块间有序==

![](王道查找(一).assets/31.png)





### 1.4.1、算法思想

![](王道查找(一).assets/32.png)

例如我们要查找22，先在第一个区块内查找不符合，再在第二个区块内查找不符合，再在第三个区块内查找符合，在第三个区块内从下标6开始查找

- 分块查找，又称**索引顺序查找**
  - 在索引表中确定待查记录所属的分块(**可顺序、可折半**)
  - 在块内顺序查找

### 1.4.2、用折半查找查索引

![](王道查找(一).assets/33.png)

如果要查找的关键字是30：

1. 将low指向第一个分块，将high指向最后一个分块
2. mid 指向 (0+4)/2 = 2，mid 指向第二个分块
3. 从下标为6开始向后对比，等查找到8号则查找成功

来看一个查找失败的例子：

![](王道查找(一).assets/34.png)

假如要查找的是关键字19：

1. mid = (low+high) = （0+4）/2 = 2, 30>19，所以只能在左边区域
2. 将 high 指向 mid 左边位置，mid = (0+1)/2 = 0,19>10,所以只能在右边区域

![](王道查找(一).assets/35.png)



3. 将low指向mid右边位置，mid = (1+1)/2 = 1

![](王道查找(一).assets/36.png)

4. 20>19,所以将 high 指向 mid 左边位置，则 low > high，折半查找失败。但是我们的表中明明存在19呀 ~，**所以在分块查找的索引表使用折半查找当 low > high 时，我们还要继续在 low 所指分块中查找。**但如果low超出索引表范围，则查找失败。

![](王道查找(一).assets/37.png)



### 1.4.3、查找效率分析ASL

![](王道查找(一).assets/40.png)

如上图，共有14个元素各自被查找的概率为1/14

- 若索引表采用顺序查找：
  - 若要查找的元素是7，先对比第一个块，再对比块内的第一个元素，共需要对比2次
  - 若要查找的元素是10，先对比第一个块，再对比块内的第一个元素、第二个元素，共需要对比3次

- 若索引表采用折半查找：
  - 若要查找的元素是30，先对比第2个块，再对比块内的第一个元素、第二个元素、第三个元素，共需要对比4次

---

考试很少考上面那种，有可能考下面这种均匀分块：

![](王道查找(一).assets/41.png)



### 1.4.4、小结

![](王道查找(一).assets/42.png)







## 1.5、红黑树

|      | BST二叉排序树 | AVL平衡二叉树 | RBT红黑树  |
| ---- | ------------- | ------------- | ---------- |
| 查找 | O(n)          | O(log~2~n)    | O(log~2~n) |
| 插入 | O(n)          | O(log~2~n)    | O(log~2~n) |
| 删除 | O(n)          | O(log~2~n)    | O(log~2~n) |



- 平衡二叉树AVL：插入删除很容易破坏平衡特性，需要频繁调整树的形态。
  - 如：插入操作导致不平衡，则需要先计算平衡因子，找到最小不平衡子树（时间开销大），再进行LL/RR/LR/RL调整
- 红黑树RBT：插入删除很多时候不会破坏红黑特性，无需频繁调整数的形态，即便需要调整，一般都可以在**常数级时间内完成**
- **平衡二叉树：适用于以查为主、很少插入/删除的场景**
- **红黑树：适用于频繁插入、删除的场景，实用性更强**



### 1.5.1、红黑树的定义

- 红黑树是二叉排序树：左子树结点值 ≤ 根结点值 ≤ 右子树结点值
- 与普通二叉排序树相比：
  1. **每个结点是红色，或是黑色的**
  2. **根结点是黑色的**
  3. **叶结点(外部结点、NULL结点、失败结点)均是黑色的**
  4. **不存在两个相邻的红结点（即红结点的父节点和孩子结点均是黑色）**
  5. **对每个结点，从该结点到任一叶结点的简单路径上，所含黑结点的数目相同**

> 左根右，根叶黑，不红红，黑路同
>
> - 左根右：左子树结点值 ≤ 根结点值 ≤ 右子树结点值
> - 根叶黑：根结点和叶节点必须是黑色的
> - 不红红：两个红结点不能连接
> - 黑路同：从任一非叶结点到任一叶结点的路径上黑结点数目相同

![](王道查找(一).assets/43.png)



- 叶结点 = 失败结点 = NULL 结点，红黑树的叶结点和普通树的叶结点不一样

- 17结点是红色的，则它的父节点必须是黑色的，它的两个儿子结点也必须是黑色的
- 22和27不算是连续的红色结点，因为他们两没有连接在一起(兄弟关系可以出现连续的红色结点，但父子关系不行)

- 从根节点出发到下面的叶节点
  - 13-8-1-叶：经过2个黑结点(不算根节点)
  - 13-8-1-6-叶：经过2个黑结点(不算根节点)
  - 到任一叶子结点所经过的黑结点数量一定是要相同的

![](王道查找(一).assets/44.png)

考题可能这么出(｡･∀･)ﾉﾞ

- 违反不红红

- 违反根叶黑

- 违反黑路同

  

### 1.5.2、黑高

![](王道查找(一).assets/45.png)

结点的黑高bh：从某结点出发(不含该结点)到达任一空叶结点的路径上黑结点总数

- 比如15结点出发到任一空叶结点经过的黑结点总数是2，所以15结点的黑高=2



> 若根结点黑高为h，内部结点数(关键字)最多有 2^2h^-1 个

### 1.5.3、红黑树的性质

1. 从根节点到叶结点的最长路径不大于最短路径的2倍
   - 最长路径就是红黑相间
2. 有n个内部结点的红黑树高度 h ≤ 2log~2~(n+1)
   - 有n个内部结点也就是有n个关键字

3. 红黑树查找操作时间复杂度 = O(log~2~n)，查找效率与AVL树同等数量级









### 1.5.4、红黑树的查找

与 BST、AVL 相同，从根出发，左小右大，若查找到一个空叶节点，则查找失败 





### 1.5.5、红黑树的插入

![](王道查找(一).assets/46.png)

红黑树插入步骤：

- 先查找，确定插入位置(原理同二叉排序树)，插入新结点
- 若新结点是根，将其染成黑色
- 若新结点非根，将其染成红色
  - 若插入新结点后仍然满足红黑树定义，则插入结束
  - 若插入新结点后不满足红黑树定义，则需要调整，使其重新满足红黑树定义（如何调整：看新结点叔叔的脸色【叔叔就是新结点的父结点的兄弟结点】）
    - 黑叔：旋转+染色
      - LL型：右单旋，父换爷+染色(父、爷颜色取反)
      - RR型：左单旋，父换爷+染色(父、爷颜色取反)
      - LR型：左、右双旋，儿换爷+染色
      - RL型：右、左双旋，儿换爷+染色
    - 红叔：染色+变新
      - 叔父爷染色，爷变为新结点

---

OK，现在静下心来，我们来看一个例子：

![](王道查找(一).assets/47.png)

1. 先插入20，先插入的是根节点，**将其染成黑色**
2. 之后插入10，10<20，向左走，插入在20的左子树，**非根将其染成红色**
3. 之后插入5，插入在10的左子树，**非根将其染成红色**
   - 新结点插入违反了不红红，并且叔结点是黑叔，新结点是插入了左子树的左子树上，LL型， **右单旋，父换爷+染色**
     - 和平衡二叉树一样，右单旋(如上图)，染色只需要染父结点和爷结点，颜色取反。
   - 这样这棵树又满足红黑树特性

![](王道查找(一).assets/48.png)



4. 之后插入30，插入在20的右子树，**非根将其染成红色**
   - 新结点插入违反了不红红，并且叔结点是红叔，**叔父爷染色，爷变为新结点**
     - **叔父爷染色**：颜色取反
     - **爷变为新结点**：新插入的30爷结点是10，通过颜色取反之后，我们将爷结点10看作是新插入的结点，对于新结点是根，则染为黑色，所以10颜色变为黑色



![](王道查找(一).assets/49.png)





5. 之后插入40，插入在30的右子树，**非根将其染成红色**
   - 新结点插入违反了不红红，并且叔结点是黑叔，**RR型，左单旋，父换爷+染色**

> 我们每次插入新结点，其他三条性质不会被违背，只需看是否违背了**不红红**特性。



### 1.5.6、小结

![](王道查找(一).assets/50.png)





## 1.5、B树

![](王道查找(一).assets/38.png)



B树，又称**多路平衡查找树**，B树中所有结点的孩子个数的最大值称为B树的阶，通常用m表示。一棵m阶B树或为空树，或为满足如下特性的m叉树：

1. 树中每个结点至多有m棵子树，即每个结点至多含有m-1个关键字
2. 若根节点不是终端结点，则至少有两棵子树。
3. 除根节点外的所有非叶子结点至少有 ⌈m/2⌉棵子树，即至少含有 ⌈m/2⌉-1 个关键字。
4. 所有的**叶结点都出现在同⼀层次**上，并且不带信息(可以视为外部结点或类似于折半查找判定树的查找失败结点，实际上这些结点不存在，指向这些结点的指针为空)
4. 所有的非叶结点结构如下：

![](王道查找(一).assets/51.png)

- P~0~、P~1~ ..... 是结点内的指针，一共有 n-1 个指针(如上图黑色箭头)
- K~1~、K~2~ ..... 是结点内的关键字，一共有 n 个关键字，满足 K~1~ < K~2~ <.....< K~n~
- P~i-1~ 所指的子树中所有结点的关键字均小于 K~i~
- P~i~ 所指的子树中所有结点的关键字均大于 K~i~
- n为结点中关键字的个数

> 在B树当中，我们把失败结点称为叶子结点，而最下面一层含有实际数据的称为终端结点



 如上图：5阶B树，所有结点的最大孩子数 m = 5

1. 结点的孩子个数等于该结点中关键字个数+1。 3 = 2 + 1

2. 如果根节点没有关键字就没有子树，此时B树为空；如果根结点有关键字，则其子树必然大于等于两棵，因为子树个数 = 关键字个数 + 1

   > 任 一 结点都要绝对平衡。(平衡因子必然为0)

3. 除根节点外的所有非终端结点至少有 ⌈ m/2 ⌉ = ⌈ 5/2 ⌉ = 3棵子树(也就是至少有 ⌈ 5/2 ⌉-1 = 2个关键字 )，最多有5棵子树(即至多有 4 个关键字)
4. 节点中关键字从左到右递增有序关键字两侧均有指向指数的指针，左边指针所指子树的所有关键字均小于该关键字，右边指针所指子树的所有关键字均大于该关键字。
5. 所有叶节点均落在第4层，代表查找失败的位置

总结：

![](王道查找(一).assets/52.png)





### 1.5.1、B树的高度

含n个关键字的m叉B树，树高最小和最大高度公式：
$$
log_m(n+1) ≤ h ≤ log_{⌈ m/2⌉} \frac{n+1}{2}+1
$$


例如：一棵3阶B树共有8个关键字， m = 3，n=8，高度范围： 
$$
log_39 ≤ h  ≤ log_24.5+1
$$


### 1.5.2、B树的插入

![](王道查找(一).assets/53.png)



如上图，我们要构造一颗5阶B树，所有结点的最大孩子数 m= 5，也就是结点内的关键字的个数为[2,4]。

- 在插入Key后，若导致原结点关键字数超过上限，则从中间位置(⌈m/2⌉)将其中的关键字**分为两部分**，左部分包含的关键字放在原结点，右部分包含的关键字放到新结点中，中间位置(⌈m/2⌉)的结点插入原结点的父结点
  - 插入25、38、49、60，当插入80时超出关键字上限，从 ⌈5/2⌉ = 3处将关键字分为两部分
    - 3处左边的25、38为左子树
    - 3处的元素升高为父结点
    - 3处右边的60、80为右子树

![](王道查找(一).assets/54.png)





- 插入90，新元素一定是插入到**最底层终端结点**，用查找来确定插入位置

  - 插入90，从根结点出发，90>49，而49的右边已经没有关键字了，所以90插入到49右边的指针所指的这个结点中，90>60，90>80，所以90插入到80后

    

![](王道查找(一).assets/55.png)



- 插入99，插入88
  - 关键字字数超过上限
  - 将88上升，88左边为左子树，右边为右子树

![](王道查找(一).assets/56.png)



- 插入80
  - 关键字字数超过上限
  - 将80上升，80左边为左子树，右边为右子树
  - 80放到父结点，也要保证父结点有序

> 当父结点关键字爷超过了上限，则继续进行分裂操作，进而导致B数高度增1





### 1.5.3、B树的删除

![](王道查找(一).assets/57.png)



若被删除关键字在**终端节点**，则直接删除该关键字（要注意结点关键字个数是否低于下限 ⌈ m/2⌉-1）

- 删除结点60，由于60是终端结点，所以直接删除
- 并且结点关键字 ≥ 下限2

![](王道查找(一).assets/58.png)



若被删除关键字在非终端节点，则可用直接前驱或直接后继来替代被删除的关键字

- 直接前驱：当前关键字左侧指针所指子树中的**最右下元素**
- 直接后继：当前关键字右侧指针所指子树中的**最左下元素**

> 对非终端结点关键字的删除，必然可以转化为对终端结点的删除操作



![](王道查找(一).assets/59.png)



若被删除关键字所在结点删除前的关键字个数低于下限，且与此结点左(或右)兄弟结点的关键字个数还很宽裕，则需要调整该结点、左(或右)兄弟结点及其双亲结点(**父子换位法**)

- 删除38之后，使得结点关键字低于下限2
- 让其右兄弟结点贡献出最小关键字70，让70上升至父结点，父结点最小元素49补充到不够的结点



![](王道查找(一).assets/60.png)

删除90结点关键字低于下限，用其左兄弟87上升至父结点，父结点的88填补不够的结点

> 本质：要永远保证子树0 < 关键字1 < 子树1 < 关键字2 ....
>
> - 人话：一个关键字左子树比它小，右子树比它大

![](王道查找(一).assets/61.png)



若关键字不够的结点的左右兄弟结点关键字不能借，则将关键字删除后，合并左右兄弟以及双亲结点中的关键字。

- 删除49，将25、70、71、72 合并为一个结点
- 但是由于合并了父结点的值，所以父结点关键字又不够了，且父结点左右兄弟也不能借，所以继续合并

![](王道查找(一).assets/62.png)





### 1.5.4、小结

![](王道查找(一).assets/63.png)







## 1.6、B+树

![](王道查找(一).assets/64.png)

一棵m阶B+树需满足下列条件：

- 每个分支结点最多有 m 棵子树(孩子结点)
- 非叶根结点至少有两棵子树，其他每个分支结点至少有 ⌈ m/2 ⌉ 棵子树。
  - B+树中将最下面一层为叶子结点(叶子结点是一大块，里面包含多个关键字)
- **结点的子树个数与关键字个数相等**
- 所有**叶结点包含全部关键字及指向相应记录的指针**，叶结点中将关键字按大小顺序排列，并且**相邻叶结点按大小顺序相互链接起来**。
- 所有分支结点中仅包含它的各个子结点中**关键字的最大值**及指向其子结点的指针。

如上图，4阶B+树：

- 每个分支结点最多有4棵子树

- 非叶根结点：既不是根结点，也不是叶子结点的结点至少有两棵子树

- 每个结点有几个关键字，就会有几个分支

  

![](王道查找(一).assets/65.png)

1. 第1颗B+树只有一个根节点，根节点下方没有其他结点，所以这个根结点同时也是**根叶子结点**(既是根又是叶子结点)
2. 第2棵B+树根节点下方有其他结点，所以这个根节点不是根叶子结点，只是根结点
   - 由于不满足非叶根节点至少有两棵子树，所以这个树不是B+树
3. 第3棵B+树根节点下方有其他结点，所以这个根节点不是叶子结点，只是根节点
   - 由于满足非叶根节点至少有两棵子树，所以这个树是B+树

> 非叶根结点至少有两棵子树





### 1.6.1、B+树的查找

B+树中无论查找成功与否，最终一定都要走到最下面一层结点。

B树中查找成功，可能停在任何一层

![](王道查找(一).assets/66.png)

假如要找编号为9所对应学生的信息：

- 首先从根结点出发，9<15，指针指向左子树的结点，依次遍历直到找到9
- 查找仍未结束，因为要找到最后一层叶子结点之后对应的记录





### 1.6.2、B树和B+树🔥

m阶B+树中：

1. 结点中的n个关键字对应n棵子树
2. 根节点的关键字数 n ∈ [1,m] ，其他结点(非根、非叶结点)的关键字数 n ∈ [ ⌈ m/2 ⌉，m]
3. 叶结点包含全部关键字，非叶结点中出现过的关键字也会出现在叶结点中
4. 叶结点包含信息，所有非叶结点仅起索引作用，非叶结点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址

m阶B树中：

1. 结点中的n个关键字对应n+1棵子树
2. 根节点的关键字数 n ∈ [1,m-1] ，其他结点的关键字数 n ∈ [ ⌈ m/2 ⌉-1，m-1]
3. 各结点中包含的关键字是不重复的
4. B树的结点多包含了关键字对应的记录的存储地址

![](王道查找(一).assets/67.png)















## 1.7、散列表的查找(王卓)

基本思想：记录的存储位置与关键字之间存在对应关系，对应关系-hash函数

优点：查找效率高

缺点：空间效率低

散列方法：选取某个函数，依该函数按关键字计算元素的存储位置，并按此存放。查找时，由同一个函数对给定值k计算地址，将k与地址单元中元素关键码进行对比，确定查找是否成功。

散列函数：散列方法中使用的转换函数

冲突：不同的关键码映射到同一个散列地址：key1 ≠ key2，但是H(key1) = H(key2)

![](王道查找(一).assets/79.png)





### 1.7.1、直接定址法

$$
Hash(key) = a×key + b (a、b为常数)
$$

优点：以关键码key的某个线性函数值为散列地址，不会产生冲突。

缺点：要占用连续地址空间，空间效率低

![](王道查找(一).assets/80.png)





### 1.7.2、除留余数法 

$$
Hash(key) = key mod p (p是一个整数)
$$



关键：如何选取合适的p？

技巧：设表长为 m， 取 p≤m 且为质数

![](王道查找(一).assets/81.png)







### 1.7.3、处理冲突的方法

#### 1.7.3.1、开放定址法(开地址法)

基本思想：有冲突时就去寻找下一个空的单列地址，只要散列表足够大，空的散列地址总能找到，并将数据元素存入。

例如：除留余数法： H~i~ =(Hash(key)+d~i~) mod m  d~i~为增量序列

常用方法：

- 线性探测法 d~i~ 为 1、2、....3、m-1 线性序列
- 二次探测法 d~i~为 1^2^ 、 -1^2^、2^2^、-2^2^、.....,q^2^ 二次序列
- 伪随机探测法 d~i~为伪随机数序列

1. **线性探测法**

例：关键码集为{47、7、29、11、16、92、22、8、3}，散列表表长为 11，散列函数为 `Hash(key)=key mod 11`,请用线性探测法解决冲突。

![](王道查找(一).assets/82.png)

| Hash(key)                                                    | 运算次数 |
| ------------------------------------------------------------ | -------- |
| 47%11 = 3                                                    | 1        |
| 7%11 = 7                                                     | 1        |
| 29%11 = 7，发生冲突，(7+1)%11 = 8                            | 2        |
| 11%11 = 0                                                    | 1        |
| 16%11 = 5                                                    | 1        |
| 92%11 = 4                                                    | 1        |
| 22%11 = 0,发生冲突，(0+1)%11 = 1                             | 2        |
| 8%11 = 8,发生冲突,(8+1)%11 = 9                               | 1        |
| 3%11 = 3,发生冲突。(3+1)%11 = 4,发生冲突。(3+2)%11 = 5，发生冲突。(3+3)%11 = 6 | 4        |

平均查找长度ASL =(1+2+1+1+1+4+1+2+2)/9 = 1.67 

​	

2. **二次探测法**

例：关键码集为{47、7、29、11、16、92、22、8、3}，设散列函数为 `Hash(key)=key mod 11`,H~i~=(Hash(key)+d~i~) mod m。其中：m为散列表长度,m要求是某个 4k+3 的质数，d~i~为增量序列 1^2^ 、 -1^2^、2^2^、-2^2^、.....,q^2^ 

![](王道查找(一).assets/83.png)

Hash(3)=3,散列地址冲突，由 H~1~ = (Hash(3)+1^2^) mod 11 = 4,依然冲突，H~2~ = (Hash(3)-1^2^) mod 11 = 2,找到空的散列地址，存入。















#### 1.7.3.2、链地址法(拉链法)

基本思想：相同散列地址的记录链成一单链表，m个散列地址就设 m 个单链表，然后用数组将 m 个单链表的表头指针存储起来，形成一个动态的结构。

![](王道查找(一).assets/84.png)



19%13 = 7

14%13 = 1

23%13 = 10

1%13 = 1

68%13 = 3

..... 

我们计算散列地址，地址相同的放在同样的单链表上，散列表的个数由 key mod m 中的m来决定，上图中m为13，得到的余数为 0~12 ，所有有13个单链表。

---

链地址法建立散列表步骤：

1. 取数据元素的关键字key，计算其散列函数值(地址)。若该地址对应的链表为空，则将该元素插入此链表；否则执行步骤2解决冲突
2. 根据选择的冲突处理方法，计算关键字key的下一个存储地址，若该地址对应的链表不为空，则利用链表的前插法或后插法将该元素插入此链表。

**链地址法优点**：

- 非同义词不会冲突，无"聚集"现象
- 链表上结点空间动态申请，更适合于表长不确定的情况。

#### 1.7.3.3、散列表查找性能分析

例题：已知一组关键字(19,14,23,1,68,20,84,27,55,11,10,79),散列函数为：H(key)=key mod 13,散列表长为 m=16，设每个记录的查找概率相等。

散列表长为16

![](王道查找(一).assets/85.png)

1. **使用线性探测再散列处理冲突**

| H(key)                                                       | 比较次数 |
| ------------------------------------------------------------ | -------- |
| H(19) = 19%13 = 6                                            | 1        |
| H(14) = 14%13 = 1                                            | 1        |
| H(23) = 23%13 = 10                                           | 1        |
| H(1) = 1%13 = 1,冲突。H(1) = (1+1)%13 = 2                    | 2        |
| H(68) = 68%13 = 3                                            | 1        |
| H(20) = 20%13 = 7                                            | 1        |
| H(84) = 84%13 = 6,冲突。H(84) = (6+1)%13 = 7,冲突。H(84) = (6+2)%13 = 8 | 3        |
| H(27) = 27%13 = 1,冲突。H(27) = (1+1)%13 = 2,冲突。H(27) = (1+2)%13 = 3,冲突。<br>H(27) = (1+3)%13 = 4,冲突。 | 4        |

平均查找长度ASL = (1*6+2+ 3 * 3+4+9)/12 = 2.5

2. **使用链地址法处理冲突**

![](王道查找(一).assets/86.png)



---

使用平均查找长度ASL来衡量查找算法，ASL取决于：

- 散列函数
- 处理冲突的方法
- 散列表的**装填因子α**

$$
α = \frac{表中填入的记录数}{哈希表的长度}
$$





> α越大，表中记录越多，说明表装的越满，发生冲突的可能性就越大，查找时比较次数就越多



#### 1.7.3.4、几点结论

- 散列表技术具有很好的平均性能，优于一些传统的技术
- 链地址法优于开地址法
- 除留余数法做散列函数优于其他类型函数



























