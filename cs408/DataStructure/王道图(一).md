# 1、图

## 1.1、图的定义

**图G**由**顶点集V**和**边集E**组成，记为G=(V,E),其中V(G)表示图G中顶点的有限非空集，E(G)表示图G中顶点之间的关系(边)集合。

若V={V~1~,V~2~,...,V~n~},则用`|v|`表示图G中`顶点的个数`,也称为`图G的阶`，E={(u,v)|u∈V,v∈V},用`|E|`表示图G中边的条数。

> 注意：线性表可以是空表，树可以是空树，但图不可以是空，即V一定是非空集。

![](王道图(一).assets/1.png)

> - 图中的边都必须连接顶点(若有边)
> - 一个图的顶点必须是非空集，但是边集可以是空集





## 1.2、有向图和无向图

![](王道图(一).assets/2.png)

- 无向图：顶点之间的连接没有箭头
- 有向图：顶点之间的连接有箭头
- 弧头：箭头指向的顶点
- 弧尾：箭头末端指向的顶点





## 1.3、简单图和多重图

![](王道图(一).assets/3.png)







## 1.4、度

![](王道图(一).assets/4.png)

对于无向图：

- 顶点的度是指顶点连接了几条边
- ==无向图的全部顶点的度的和等于边数的2倍==

对于有向图：

- 入度：有多少个箭头指向这个顶点

- 出度：有多少个箭头从这个顶点向外发射的
- 有向图顶点的度等于其入度和出度之和，入度之和和出度之和相等且等于边数e
- ==有向图全部顶点的度的和等于边数的2倍==





## 1.5、顶点关系描述

![](王道图(一).assets/5.png)



- 路径：顶点V~1~到顶点V~2~之间的一条路径是指顶点序列
  - 例如A到C的路径是指：A、B、E、D 或者 A、B、D

- 回路：第一个顶点和最后一个顶点相同的路径称为回路或环
  - 例如从B到D到E再回到B
- 简单路径：在路径序列中，顶点不重复出现的路径称为简单路径
  - A到B到E到D为简单路径，A到B到E再到B到D就不是简单路径
- 简单回路：除第一个顶点和最后一个顶点外，其余顶点不重复出现的回路称为简单回路

- 路径长度：路径上边的数目
- 点到点的距离：从顶点u出发到顶点v的最短路径若存在，则此路径的长度称为u到v的距离。若从u到v根本不存在路径，则记该距离为无穷。

- 无向图中，若从顶点v到顶点w有路径存在，则称v和w是**连通**的
- 有向图中，若从顶点v到顶点w和从顶点w到顶点v之间都有路径，则称这两个顶点是**强连通**的(既有正向路径，又有逆向路径)

![](王道图(一).assets/6.png)

如下图：4个顶点的无向图，要想是连通图，最少要有3条边。要想是非连通图，其中3个顶点两两相连C~3~^2^ 条边，若再加1条边，就变成连通图了。4个顶点的有向图，要是强连通图，则必须形成回路。

![](王道图(一).assets/26.png)

## 1.6、子图

![](王道图(一).assets/7.png)

子图：取出顶点集的子集，再取出边集中的子集，用这样方式构建的图就是原图的子图。

- 注意：子图必须是一个图，上述右下角构建的不符合图的定义，若有边则每条边都需要连接顶点 

生成子图：**如果子图里面包含原图当中的所有顶点**，那么这个子图就可以称为原图的一个生成子图。







## 1.7、连通分量

**无向图**中的**极大连通子图**称为**连通分量**。

![](王道图(一).assets/8.png)

如上图，我们将无向图G分成3个连通分量，每个连通分量都是原图的一个子图，并且**子图必须连通，且包含尽可能多的顶点和边**(称为极大连通子图)。







## 1.8、强连通分量

有向图中的**极大强连通子图**称为有向图的**强连通分量。**

![](王道图(一).assets/9.png)





## 1.9、生成树

![](王道图(一).assets/12.png)

连通图的**生成树**是==包含图中全部顶点的一个极小连通子图==(边尽可能的少，但是要保持连通)。

**若图中顶点数为n，则它的生成树含有n-1条边。对生成树而言，若砍去它的一条边，则会变成非连通图，若加上一条边则会形成一个回路。**

> 生成树不唯一，可能有多个，例如上图画出的两个

## 1.10、生成森林

![](王道图(一).assets/13.png)











## 1.11、边的权

- 边的权：在一个图中，每条边都可以标上具有某种含义的数值，该数值称为该边的权值
- 带权图/网：边上带有权值的图称为带权图，也称网
- 带权路径长度：当图是带权图时，一条路径上所有边的权值之和，称为该路径的带权路径长度



## 1.12、几种特殊形态的图

![](王道图(一).assets/14.png)

- 无向完全图的顶点为n，则边的条数为C~n~2= n(n-1)/2
- 有向完全图的顶点为n，则边的条数为2C~n~2= n(n-1)





![](王道图(一).assets/15.png)

![](王道图(一).assets/16.png)

无向树：不存在回路，且连通的无向图

有向树：一个顶点的入度为0、其余顶点的入度均为1的有向图，称为有向树。

常见考点：n个顶点的图，若边数 >n-1，则一定有回路

## 1.13、小结

对于n个顶点的无向图G：

- 所有顶点的度之和=边数的2倍
- 若G是连通图，则最少有n-1条边（树），若边数e>n-1，则一定有回路
- 若G是非连通图，则最多可能有C~n-1~2条边
- 无向完全图共有C~n~2条边

对于n个顶点的有向图G：

- 所有顶点的出度之和 = 入度之和 = e
- 所有顶点的读之和 = 2e
- 若G是强连通图，则最少有 n 条边(形成回路)
- 有向完全图共有 2C~n~2 条边





# 2、图的存储

## 2.1、邻接矩阵

在邻接矩阵法里面，0表示两个顶点之间相互不邻接，1表示邻接

![](王道图(一).assets/20.png)

- 在无向图中，A和B之间有边，同时意味着B和A之间也有一条边，A行B列和B行A列都是1。A和E之间没有边，所以A行E列和E行A列是0


```c
#define MaxVertexNum 100  // 顶点数目的最大值
typedef struct{
    char Vex[MaxVertexNum];	// 顶点表
    int Edge[MaxVertexNum][MaxVertexNum]; // 邻接矩阵,边表
    int vexnum,arcnum;		// 图的当前顶点数和边数/弧数
}MGraph;
```

![](王道图(一).assets/21.png)

对于无向图：第i个结点的度=第i行(或第i列)的非零元素个数。

对于有向图：

- 第i个结点的出度=第i行的非零元素个数
- 第i个结点的入度=第i列的非零元素个数
- 第i个结点的度=第i行、第i列的非零元素个数之和

> 邻接矩阵法求顶点的度/出度/入度的时间复杂度是O(n)



### 2.1.1、邻接矩阵法存储带权图(网)

![](王道图(一).assets/22.png)



我们要存储网的话只需要在对应位置写上权值，若**两顶点不存在边**的话我们可以使用无穷或者0来表示

```c
#define MaxVertexNum 100 //顶点数目的最大值
#define char VertexTypel; //宏定义常量"无穷"
typedef char VertexType;	// 顶点的数据类型
typedef int EdgeType; //带权图中边上权值的数据类型
typedef struct{
    VertexType Vex[MaxVertexNum]; //顶点
    EdgeType Edge[MaxVertexNum][MaxVertexNum]; //边的权
    int vexnum,arcnum;		// 图的当前顶点数何弧数
}MGraph;
```





### 3.1.2、邻接矩阵法的性能分析

![](王道图(一).assets/23.png)

图有n个顶点，存储各个顶点的信息需要一个一维数组，也就是O(n)，另外我们还需要定义一个 n*n 的二维数组来存储边的信息

- 空间复杂度 = O(n)+O(n^2^)=O(n^2^) ,只和顶点数相关,和实际的边数无关。

- 适合用于存储稠密图。

- 无向图的邻接矩阵是**对称矩阵**，可以进行压缩存储(只存储上三角区/下三角区)



### 2.1.3、邻接矩阵法的性质

设图G的邻接矩阵为A(不带权的无向图，矩阵元素为0/1)，则 A^n^ 的元素A^n^[i] [j] 等于由顶点 i 到顶点 j 的长度为n的路径的数目。

![](王道图(一).assets/27.png)





## 2.2、邻接表法

### 2.2.1、无向图的邻接表

邻接矩阵是数组实现的顺序存储，**空间复杂度高，不适合存储稀疏图**。邻接表是顺序+链式存储

无向图的邻接表：用一维数组来存储各个顶点的信息，用链表存储关联同一顶点的边(就是树章节的孩子表示法)

![](王道图(一).assets/24.png)

0表示A，1表示B，2表示C，3表示D。如上图，A连接B、C、D，所以A结点后面的链表连接了1、2、3。

```c
// 边弧
typedef struct ArcNode{
    int adjvex;  	// 边/弧指向哪个结点
    struct ArcNode *next;	// 指向下一条弧的指针
    // InfoType info	// 边权值
}ArcNode;

// 顶点
typedef struct VNode{
    VertexType data; 	//顶点信息
    ArcNode *first;		//第一条边/弧
}VNode,AdjList[MaxVertexNum];

// 用邻接表存储的图
typedef struct{
    AdjList vertices;
    int vexnum,arcnum;
}ALGraph;
```

无向图的邻接表特点：

- 邻接表不唯一
- 若无向图中有n个顶点、e条边，则其邻接表需n个头结点和2e个边结点。空间复杂度为O(n+2e)
- 无向图中顶点V~i~的度为第 i 个单链表中的结点数
- 适宜存储稀疏图





### 2.2.2、有向图的邻接表

有向图的邻接表：只记录顶点发出的弧

![](王道图(一).assets/28.png)

有向图的邻接表特点：

- 若有向图中有n个顶点、e条边，则其邻接表需n个头结点和e个边结点。空间复杂度为O(n+e)

- 顶点V~i~的出度为第i个单链表中的结点个数，顶点V~i~的入度则需要遍历所有的单链表

- 只要确定了顶点编号，图的邻接矩阵表示方式唯一，但邻接表不唯一

  



### 2.2.3、小结

|                  | 邻接矩阵           | 邻接表                                 |
| ---------------- | ------------------ | -------------------------------------- |
| 空间复杂度       | O(n^2^)            | 无向图O(n+2e);有向图O(n+e)             |
| 适合用于         | 存储稠密图         | 存储稀疏图                             |
| 表示方式         | 唯一               | 不唯一                                 |
| 计算度/出度/入度 | 必须遍历对应行或列 | 计算有向图的度、入度不方便，其余很方便 |
| 找相邻的边       | 必须遍历对应行或列 | 找有向图的入边不方便,其余很方便        |

## 2.3、十字链表(存储有向图)

![](王道图(一).assets/29.png)

十字链表法性能分析：

- 空间复杂度：`O(n+e)`
- 顶点的所有出边：顺着**绿色**线路找；顶点的所有入边：顺着**橙色**路线找
  - 例如A的出边：B、C ，A的入边：C、D
- 注意：十字链表只用于存储有向图









## 2.4、邻接多重表(存储无向图)

![](王道图(一).assets/30.png)

邻接多重表性能分析：

- 空间复杂度：`O(n+e)`
- 删除边、删除结点等操作很方便
- 注意：邻接多重表只适用于存储无向图

## 2.5、小结

|                  | 邻接矩阵                               | 邻接表                                      | 十字链表     | 邻接多重表   |
| ---------------- | -------------------------------------- | ------------------------------------------- | ------------ | ------------ |
| 空间复杂度       | O(n^2^)                                | 无向图O(n+2e);有向图O(n+e)                  | O(n+e)       | O(n+e)       |
| 适合用于         | 存储稠密图                             | 存储稀疏图                                  | 只能存有向图 | 只能存无向图 |
| 表示方式         | 唯一                                   | 不唯一                                      | 不唯一       | 不唯一       |
| 找相邻的边       | 必须遍历对应行或列，时间复杂度为O(n)   | 找有向图的入边必须遍历整个邻接表,其余很方便 | 很方便       | 很方便       |
| 删除边或顶点     | 删除边很方便，删除顶点需要大量移动数据 | 无向图中删除边或顶点都不方便                | 很方便       | 很方便       |
| 计算度/出度/入度 | 必须遍历对应行或列                     | 计算有向图的度、入度不方便，其余很方便      |              |              |





# 3、图的基本操作

## 3.1、判断图是否存在边

无向图：

![](王道图(一).assets/31.png)

例如

- 在邻接矩阵中，想要判断两个顶点之间是否有边：比如判断B和D之间是否有边，只需要看B行D列所对应的元素是否是1。这个操作只需要`O(1)`的时间复杂度
- 在邻接表中，想要判断两个顶点之间是否有边：比如判断B和D之间是否有边，只需要看B的边结点有没有D(也就是3)，最好的情况就是3是链表的第一个结点，这种最好时间复杂度是`O(1)`，最坏的情况是遍历完所有边结点也没有3，而和B连接的边最多有n-1条，所以最坏时间复杂度是`O(n)`
  - 时间复杂度是： `O(1) -> O(n)`

---

有向图：

![](王道图(一).assets/32.png)

例如

- 在邻接矩阵中，想要判断两个顶点之间是否有边：比如判断B和D之间是否有边，只需要看B行D列所对应的元素是否是1。这个操作只需要`O(1)`的时间复杂度
- 在邻接表中，想要判断两个顶点之间是否有边：比如判断B和D之间是否有边，只需要看B的边结点有没有D(也就是3)，最好的情况就是3是链表的第一个结点，这种最好时间复杂度是`O(1)`，最坏的情况是遍历完所有边结点也没有3，而和B连接的边最多有n-1条，所以最坏时间复杂度是`O(n)`
  - 时间复杂度是： `O(1) -> O(n)`





## 3.2、列出结点相邻的边

无向图：

![](王道图(一).assets/33.png)

例如

- 在邻接矩阵中，想要找到某个结点相邻的所有边：比如判断C相邻的边，只需要看C行或者C列，检查哪个是1，把这些元素所对应的边列举出来。这个操作只需要`O(n)`的时间复杂度(需要遍历n个元素)
- 在邻接表中，想要找到某个结点相邻的所有边：比如判断C相邻的边，只需要看C的边结点链表，把这些元素所对应的边列举出来，最好的情况就是边结点链表只有一个结点，这种最好时间复杂度是`O(1)`，最坏的情况是边结点链表连接了n-1个结点，所以最坏时间复杂度是`O(n)`
  - 时间复杂度是： `O(1) -> O(n)`

---

有向图：

![](王道图(一).assets/34.png)

例如

- 在邻接矩阵中，想要找到某个结点相邻的所有边：比如判断C相邻的出边，只需要看C行，检查哪个是1，把这些元素所对应的边列举出来；判断C相邻的入边，只需要看C列，检查哪个是1，把这些元素所对应的边列举出来。这个操作只需要`O(n)`的时间复杂度(需要遍历n个元素)
- 在邻接表中，想要找到某个结点相邻的所有边：比如判断C相邻的出边，只需要看C的边结点链表，把这些元素所对应的边列举出来，最好的情况就是边结点链表只有一个结点，这种最好时间复杂度是`O(1)`，最坏的情况是边结点链表连接了n-1个结点，所以最坏时间复杂度是`O(n)`。而如果要找C的入边，我们就要遍历所有的边结点链表，因此时间复杂度为`O(e)`
  - 时间复杂度是： `O(1) -> O(n)`





## 3.3、在图中插入新顶点

![](王道图(一).assets/35.png)

刚开始插入顶点，新顶点和其他任何顶点都是不相连的，

- 在邻接矩阵中，插入顶点：只需要在保存原顶点矩阵的后面写入新结点的数据。看起来好像要写入很多个0，但是其实邻接矩阵在初始化时就已经置零了，所以只需要写入这个操作，时间复杂度为`O(1)`
- 在邻接表中，插入顶点：只需要在保存原顶点数组的末尾写入新结点的信息，时间复杂度为`O(1)`

> 有向图类似，插入顶点的时间复杂度都是O(1)





## 3.4、在图中删除顶点

无向图：

![](王道图(一).assets/36.png)

![](王道图(一).assets/37.png)

- 在邻接矩阵中，删除顶点：将删除顶点对应的行和列全部置零。时间复杂度为`O(n)`
- 在邻接表中，删除顶点：删除顶点及其边结点链表，同时还要删除其他边结点链表与它相连的信息。时间复杂度为`O(1)->O(n)`

---

有向图：

![](王道图(一).assets/38.png)



- 在邻接矩阵中，删除顶点：将删除顶点对应的行和列全部置零。时间复杂度为`O(n)`
- 在邻接表中，删除顶点：删除出边——删除顶点及其边结点链表，时间复杂度为`O(1)->O(n)`。删除入边——遍历整个邻接表，时间复杂度为`O(e)`



## 3.5、在图中增加一条边

![](王道图(一).assets/39.png)



- 在邻接矩阵中，增加一条边：将邻接矩阵对应位置设为1。时间复杂度为`O(1)`
- 在邻接表中，增加一条边：例如要在C和F之间添加一条边，则需要在C的边结点链表后插入5，在F的边结点链表后插入2，时间复杂度为`O(1)-O(n)`







## 3.6、找到顶点的第一个邻接点

无向图：

![](王道图(一).assets/40.png)



- 在邻接矩阵中，找到指定顶点的第一个邻接点：例如找到C对应的第一个邻接点，只需要看C行第一个1对应的元素。时间复杂度为`O(1)-O(n)`
- 在邻接表中，找到指定顶点的第一个邻接点：例如找到C对应的第一个邻接点，只需要看C的边结点链表的第一个结点，对应的时间复杂度为`O(1)`

---

有向图：

![](王道图(一).assets/41.png)

- 在邻接矩阵中，找到指定顶点的第一个邻接点：例如找到C的出边第一个邻接点，只需要看C行的第一个1对应的元素，找到C的入边第一个邻接点，只需要看C列的第一个1对应的元素。时间复杂度为`O(1)-O(n)`
- 在邻接表中，找到指定顶点的第一个邻接点：例如找到C出边对应的第一个邻接点，只需要看C的边结点链表的第一个结点，对应的时间复杂度为`O(1)`。但是若要找C入边对应的第一个邻接点，则时间复杂度为`O(1)-O(n)`，一般不考。





## 3.7、找到第二个邻接点

![](王道图(一).assets/42.png)

- 在邻接矩阵中，找到指定顶点的第二个邻接点：例如找到C的第二个邻接点，只需要看C行的第二个1对应的元素，时间复杂度为`O(1)-O(n)`
- 在邻接表中，找到指定顶点的第一个邻接点：例如找到C的第二个邻接点，只需要看C的边结点链表的第二个结点，对应的时间复杂度为`O(1)`。





# 4、图的遍历(王卓)

这部分结合王道书来看吧...

## 4.1、广度优先遍历BFS

从图的某一顶点出发，首先依次访问该结点的所有邻接点Vi~1~，Vi~2~，Vi~3~....V~i~n ，再按这些顶点被访问的先后次序依次访问与它们想邻接的所有未被访问的顶点。重复此过程，直至所有顶点均被访问为止。

- 连通图的广度遍历

![](王道图(一).assets/43.png)

- 非连通图的广度遍历

![](王道图(一).assets/44.png)

> 采用邻接矩阵和邻接表存储会影响广度遍历序列的唯一性：
>
> - 同⼀个图的邻接矩阵表示方式唯一，因此⼴度优先遍历序列唯⼀
> - 同⼀个图邻接表表示方式不唯一，因此⼴度优先遍历序列不唯⼀

==BFS广度优先遍历分析==：

- **对于无向图，调用BFS函数的次数 = 连通分量数**
- 空间复杂度：`O(n)`
- 对于邻接矩阵存储的图，广度优先遍历的时间复杂度为==O(n^2^)==，对于邻接表存储的图，广度优先遍历的时间复杂度为`O(n+e)`
- 图的广度优先遍历相当于树的层次遍历

### 4.1.1、广度优先生成树

- 在广度遍历的过程中，我们可以得到一棵遍历树，称为**广度优先生成树**，一给定图的邻接矩阵存储表示是唯一的，故其广度优先生成树是唯一的，但是邻接表存储表示不唯一，故其广度优先生成树是不唯一的。

- **对非连通图的广度优先遍历，可得到广度优先生成森林**



## 4.2、深度优先遍历DFS

方法如下：

- 在访问图中某一起始顶点 v 后，由 v 出发，访问它的任一邻接顶点W~1~
- 再从 W~1~ 出发，访问与 W~1~ 邻接但还未被访问过的顶点W~2~
- 然后再从 W~2~ 出发，进行类似的访问
- 如此进行下去，直至到达所有的邻接顶点都被访问过的顶点u为止
- 接着，退回一步，退到前一次刚访问过的顶点，看是否还有其他没有被访问的邻接顶点
- 如果有，则访问此顶点，之后再从此顶点出发，进行与前述类似的访问
- 如果没有，那就再退回一步进行搜索。重复上述过程，直到连通图中的所有顶点都被访问过为止。

![](王道图(一).assets/45.png)



==深度优先遍历DFS分析==：

- 空间复杂度：`O(1)-O(n)`
- 对于邻接矩阵存储的图，深度优先遍历的时间复杂度为`O(n^2^)` ,对于邻接表存储的图，深度优先遍历的时间复杂度为`O(n+e)`

- 图的深度优先遍历类似于树的先根遍历



> 采用邻接矩阵和邻接表存储会影响广度遍历序列的唯一性：
>
> - 同⼀个图的邻接矩阵表示方式唯一，因此⼴度优先遍历序列唯⼀
> - 同⼀个图邻接表表示方式不唯一，因此⼴度优先遍历序列不唯⼀

### 4.2.1、深度优先生成树

- 在深度遍历的过程中，我们可以得到一棵遍历树，称为**深度优先生成树**，一给定图的邻接矩阵存储表示是唯一的，故其广度优先生成树是唯一的，但是邻接表存储表示不唯一，故其广度优先生成树是不唯一的。

- 对非连通图的广度优先遍历，可得到广度优先生成森林





## 4.3、图的遍历与图的连通性

对于无向图：

- 对**无向图**进行BFS/DFS遍历，调用BFS/DFS函数的次数=无向图的连通分量数
- 对于**连通图**，只需调用1次BFS/DFS函数

对于有向图进行BFS/DFS遍历，调用BFS/DFS函数的次数要具体问题具体分析

- 若起始顶点到其他各顶点都有路径，则只需调用1次BFS/DFS函数
- 对于**强连通图**，从任一结点出发只需调用1次BFS/DFS







# 5、图的应用

## 5.1、最小生成树

给定一个无向网，在该网中的所有生成树中，使得各边权值之和最小的那棵生成树称为该网的最小生成树，也叫最小代价生成树。

- 最小生成树可能有多个，但边的权值之和总是唯一且最小的
- 最小生成树的边数 = 顶点数-1，砍掉一条则不连通，增加一条边则会出现回路
- 如果一个连通图本身就是一棵树，则其最小生成树就是它本身
- 只有连通图才有生成树，非连通图只有生成森林



## 5.2、构造最小生成树

### 5.2.1、prime算法

算法思想:从某一个顶点开始构建生成树，每次将代价最小的新顶点纳入生成树，直到所有顶点都纳入为止。

- 设N=(V,E)是连通网，TE是N上最小生成树中边的集合
- 初始令 U={u~0~}，(u~0~∈V)，TE={}。
- 在所有 u ∈ U，v∈V-U的边(u,v)∈E中，找一条代价最小的边(u~0~,v~0~)

- 将(u~0~,v~0~)并入集合TE，同时v~0~并入U~0~
- 重复上述操作直至U=V为止，则T=(V,TE)为N的最小生成树。

例如：

我们要构造如下图的最小生成树，我们选取一个顶点，这个顶点就是U集合，其他顶点就是V-U集合

![](王道图(一).assets/46.png)

在U集合当中的顶点和V-U集合当中的顶点中找一条权值最小的边，将边关联的顶点选取到我们的U集合，其他顶点为V-U集合

![](王道图(一).assets/47.png)

之后在U集合当中的顶点和V-U集合当中的顶点中找一条权值最小的边，V1到V2为6，V1到V4为5，V3到V2为5，V3到V4为5，V3到V5为6，V3到V6为4。所以选取权值最小的边4，其关联的顶点为V6，将其加入到U集合中。此时U集合为{V1,V3,V6}

![](王道图(一).assets/48.png)

重复上述操作，V1周边的权值为6，5，V3周边的权值为5,5,6，V6周边的权值为6，V4周边不能选(一旦选了有回路成环了)

我们选择权值最小的V3到V2的5，将V2加入到U集合中

![](王道图(一).assets/49.png)

### 5.2.2、Kruskal算法

克鲁斯卡尔(Kruskal)算法

算法思想：每次选择一条权值最小的边，使这条边的两头连通(原本已经连通的就不选)，直到所有结点都连通

- 设连通网 N=(V,E)，令最小生成树初始状态为只有 n 个顶点而无边的非连通图 T=(V,{}),每个顶点自成一个连通分量

- 在E中选取代价最小的边，若该边依附的顶点落在T中不同的连通分量上(即：不能形成环)，则将此边加入到T中；否则，舍去此边，选取下一条代价最小的边。
- 以此类推，直到T中所有顶点都在同一连通分量上为止。

![](王道图(一).assets/50.png)

将所有顶点不连通，选择权最小的连接，且不能形成环。

![](王道图(一).assets/51.png)



### 5.2.3、比较

| 算法名     | 普里姆算法 | 克鲁斯卡尔算法       |
| ---------- | ---------- | -------------------- |
| 算法思想   | 选择点     | 选择边               |
| 时间复杂度 | O(N^2^)    | O(elog~2~e)(e为边数) |
| 适应范围   | 稠密图     | 稀疏图               |





## 5.3、最短路径

![](王道图(一).assets/52.png)



### 5.3.1、BFS算法求无权图的单源最短路径

无权图可以视为一种特殊的带权图，只是每条边的权值都为1。

![](王道图(一).assets/53.png)



如上图，计算2这个点到其他所有顶点的路径：执行广度优先搜索

- 从2出发可以找到相邻的1和6，     1和6距离2的最短距离是1
- 通过1和6找到相邻的有5、3、7，       5、3、7距离2的最短距离是2
- 再通过5、3、7找相邻的有4、8，       4、8距离2的最短距离是3







### 5.3.2、Dijkstra算法

![](王道图(一).assets/54.png)



我们要找到V0到其他顶点的最短路径，我们需要初始化三个数组：

- 第1个数组标记各顶点是否已找到最短路径，初始化时将V0对应的 final 值设为 true
- 第2个数组表示最短路径长度
  - V0到V0是0，V0到V1是10，V0到V4是5，并不存在从V0到V2、V3的边，设为无穷
- 第3个数组表示路径上的前驱
  - V1设为0，表示从V0到V1，V1的前驱是V0
  - V4设为0，表示从V0到V4，V4的前驱是V0



![](王道图(一).assets/55.png)



1. 第一轮：循环遍历所有结点，找到还没确定最短路径(也就是 final 值为 false)，且 dist 最小的顶点V~i~，令 final[i] = true
   - 还没确定最短路径有V1、V2、V3、V4，dist 最小的顶点是 V4，将 final[4] = true，表示对于V4的最短路径是5，并且直接前驱为V0
2. 检查所有邻接自 V~i~ 的顶点，若其 final 值为 false，则更新 dist 和 path信息
   - 检查 V1、V2、V3，它们的 final 值均为 false
     - V0 - V4 - V1 ：8，则V0到V1的长度为8，8<10，将V1的 dist 改为 8，path 改为 4
     - V0 - V4 - V2：14，则V0到V2的长度为14，14<∞，将V2的 dist 改为 14，path 改为 4
     - V0 - V4 - V3： 7 ，则V0到V3的长度为7，7<∞，将V3的 dist 改为 7，path 改为 4



![](王道图(一).assets/56.png)





1. 第二轮：循环遍历所有结点，找到还没确定最短路径(也就是 final 值为 false)，且 dist 最小的顶点V~i~，令 final[i] = true

   - 还没确定最短路径有V1、V2、V3，dist 最小的顶点是 V3，将 final[3] = true，表示对于V3的最短路径是7，并且直接前驱为V4

2. 检查所有邻接自 V~i~ 的顶点，若其 final 值为 false，则更新 dist 和 path信息

   - 检查 V0、V2，只有 V2 的 final 值为 false

     - V0 - V4 - V3-V2 ：13，则V0到V2的长度为13，13<14，将V1的 dist 改为 13，path 改为 3

       

![](王道图(一).assets/57.png)





1. 第三轮：循环遍历所有结点，找到还没确定最短路径(也就是 final 值为 false)，且 dist 最小的顶点V~i~，令 final[i] = true
   - 还没确定最短路径有V1、V2，dist 最小的顶点是 V1，将 final[1] = true，表示对于V1的最短路径是8，并且直接前驱为4
2. 检查所有邻接自 V~i~ 的顶点，若其 final 值为 false，则更新 dist 和 path信息
   - 检查 V2、V4，只有 V2 的 final 值为 false
     - V0 - V4 - V1-V2 ：8+1 = 9，则V0到V2的长度为9，9<13，将V1的 dist 改为 9，path 改为 1

![](王道图(一).assets/58.png)

最终结果如上图：

- 如果我们要找V0到V2的最短路径，通过查 dist 数组可知最短的路径长度为 9，通过 path 数组可以查到这条路线：   V0 - V4 - V1 - V2
  - V0-V2的最短(带权)路径长度 = dist[2] = 9，路线：V0 - V4 - V1 - V2



> 时间复杂度 O(n^2^)，且迪杰斯特拉算法不适用于有负权值的带权图





### 5.3.3、Floyd算法

![](王道图(一).assets/59.png)



如上有向图，我们要求三个顶点之间的最短路径：我们设置两个初始矩阵，A矩阵就是有向图的邻接矩阵，表示的是就目前来看各个顶点间的最短路径长度(初始时不允许路径在其他顶点中转，也就是只能直达)，path 矩阵表示两个顶点之间的中转点(初始不能中转，初值全部置为1)



![](王道图(一).assets/60.png)

逐步试着在原直接路径中增加中间顶点，若加入中间顶点后路径变短，则修改之，否则，维持原值。所有顶点试探完毕，算法结束

1. 若允许在V0中转，
   - V2到V1之前是∞，加入V0后，V2-V0-V1：11，11< ∞，则将A矩阵对应处修改为 11
   - path 矩阵对应处修改为 0，中转点是V0
   - 我们要对所有的都进行这样进行判断，满足上述条件的都需要更新

2. 假如允许V0、V1中转：

![](王道图(一).assets/61.png)

3. 假如允许V0、V1、V2中转

   ![](王道图(一).assets/62.png)

则根据上图：

- 根据A矩阵，V1到V2的最短路径长度为4，根据 path 矩阵， 完整路径信息为 V1-V2
- 根据A矩阵，V0到V2的最短路径长度为10，根据 path 矩阵， 完整路径信息为 V0-V1-V2
- 根据A矩阵，V1到V0的最短路径长度为9，根据 path 矩阵， 完整路径信息为 V1-V2 - V0



> Floyd算法不能解决带有负权回路(有负权值的边组成回路)
>
> - 空间复杂度O(n^2^)
> - 时间复杂度O(n^3^)



### 5.3.4、小结

![](王道图(一).assets/63.png)







## 5.4、有向无环图

有向无环图：若一个有**向图中不存在环**，则称为有向无环图，简称**DNG图**

![](王道图(一).assets/64.png)

左图不存在环(即起点和终点是一个结点)，右图：V0-V4-V3-V0，存在环路。

对于表达式构造有向无环图，如何做呢？

![](王道图(一).assets/65.png)

宗旨：顶点种不可能出现重复的操作数，例如 x、y 操作数分别只有一个，a、b、c、d、e 操作数分别只有一个。

步骤如下：

1. 把各个操作数不重复地排成一排
2. 标出各个运算符的生效顺序(先后顺序有点出入无所谓，主要是怕遗漏)

![](王道图(一).assets/66.png)



3. 按顺序加入运算符，注意"分层"
   - 第一个生效的是 + 号，左边是a，右边是 b
   - 第二个生效的是 + 号，左边是c，右边是 d
   - 第三个生效的是 × 号，左边是b，右边是 c+d，要把 × 号放到上一层，因为这个 × 号运算要基于下面一层运算的结果来进行

![](王道图(一).assets/67.png)

第四个生效的是 × 号，左边是a+b，右边是 b×(c+d)，要把 × 号放到上一层，因为这个 × 号运算要基于下面一层运算的结果来进行

![](王道图(一).assets/68.png)





4. 从底向上逐层检查同层的运算符是否可以合体
   - 最下面的一层全是 + 号，最左边 + 号左右是 a、b，右边3个 + 号左右均是 c、d，所以可以合并
   - 倒数第二层三个 × 号，右边两个 × 号左边是 c+d，右边是e，所以可以合并
   - 再向上三层由于只有一个运算符，所以肯定不需要合体操作

![](王道图(一).assets/69.png)



![](王道图(一).assets/70.png)





### 5.4.1、例题

![](王道图(一).assets/71.png)



进行合并：

- 最后一层全是 × 号，三个 × 号左右操作数均为 a、b，所以可以合并 

![](王道图(一).assets/72.png)

---



## 5.5、拓扑排序

### 5.5.1、AOV网

AOV网：用DAG有向无环图表示一个工程，顶点表示活动，有向边 <V~i~，V~j~> 表示活动 V~i~ 必须先于活动 V~j~ 进行。

- 若从i到j有一条有向路径，则i是j的前驱，j是i的后继。
- 若<i,j>是网中的有向边，则i是j的直接前驱，j是i的直接后继。
- AOV网中不允许有回路，因为如果有回路存在，则表明某项活动以自己为先决条件，显然这是荒谬的。





### 5.5.2、拓扑排序

**拓扑排序**：在AOV网没有回路的前提下，**我们将全部活动排列成一个线性序列，使得若AOV网中有弧<i,j>存在，则在这个序列中，i一定排在j的前面，具有这种性质的线性序列称为拓扑有序序列**，相应的拓扑有序排序的算法称为拓扑排序。

实现：

1. 从AOV网种选择一个没有前驱(**入度为0**)的顶点并输出
2. 从网中删除该顶点和所有以它为起点的有向边
3. 重复1、2操作直到当前的**AOV网为空**或者**当前网中不存在无前驱的顶点为止**

拓扑排序是对有向无环图的顶点的一种排序，它使得若存在一条从顶点A到顶点B的路径，则在排序中顶点B出现在顶点A的后面，每个AOV网都有一个或多个拓扑排序序列。



`来看一个例子`：

![](王道图(一).assets/73.png)

拓扑序列：C1

![](王道图(一).assets/74.png)

拓扑序列：C1、C2、C3

![](王道图(一).assets/75.png)

拓扑序列：C1、C2、C3、C4、C5

![](王道图(一).assets/76.png)

最终拓扑序列：C1、C2、C3、C4、C5、C7、C9、C10、C11、C6、C12、C8

> 注意：一个AOV网的拓扑序列不是唯一的

检测AOV网中是否存在环的方法：

对有向图构造其顶点的拓扑有序序列，若网中所有顶点都在它的拓扑有序序列中，则该AOV网必定不存在环。



![](王道图(一).assets/77.png)



## 5.6、关键路径

### 5.6.1、AOE网

在带权有向图中，以**顶点表示事件**，以**有向边表示活动**，以**边上的权值表示完成该活动的开销**，称之为用边表示活动的网络，称为**AOE网**。

AOE网具有以下两个性质：

1. 只有在某顶点所代表的**事件**发生后，从该顶点出发的各**有向边所代表的活动才能开始**
2. 只有在进入某顶点的各有向边所代表的活动都已结束时，该顶点所代表的事件才能开始，另外有些活动是可以并行进行的

![](王道图(一).assets/78.png)

- 在AOE网中仅有一个**入度为0**的顶点，称为**开始顶点(源点)**，它表示整个工程的开始
- 仅有一个**出度为0**的顶点，称为**结束顶点(汇点)**，它表示整个工程的开始
- 从源点到汇点的有向路径可能有多条，所有路径种，具有最大路径长度的路径称为 **关键路径**，而把关键路径上的活动称为 **关键活动**，完成整个工程的最短时间就是关键路径的长度，若关键活动不能按时完成，则整个工程的完成时间就会延长

==顶点代表事件，有向边代表活动==

- **事件V~k~ 的最早发生时间 Ve(k) ：决定了所有从V~k~开始的活动能够开工的最早时间**
- **事件V~k~ 的最迟发生时间 Vl(k) ：指在不推迟整个工程完成的前提下，该事件最迟必须发生的时间**
- **活动a~i~的最早开始时间 e(i)：指该活动弧的起点所表示的事件的最早发生时间**
- **活动a~i~的最迟开始时间 l(i)：指该活动弧的终点所表示的事件的最迟发生时间与该活动所需时间之差**

- 活动a~i~的时间余量 d(i) = l(i) - e(i) ，最迟开始时间 - 最早开始时间，表示在不增加完成整个工程所需总时间的情况下，活动 a~i~ 可以拖延的时间，若一个活动的时间余量为零，则说明该活动必须要如期完成， d(i) = 0即 l(i) = e(i) 的活动 a~i~ 是**关键活动**，由**关键活动**组成的路径就是**关键路径**。





### 5.6.2、步骤

![](王道图(一).assets/79.png)



从开始顶点事件开始推算其余顶点事件的最早发生时间，这样可以得到每个活动的最早发生时间，这两个值相等。

从结束顶点事件逆向推出其余顶点事件的最迟发生时间，这样可以得到每个活动的最迟发生时间

活动余量可以通过每个活动的最早发生时间和最迟发生时间作差来得到

![](王道图(一).assets/80.png)

1. 求所有事件的最早发生时间 Ve()

   - 对AOE网进行拓扑排序，根据拓扑排序的序列来依次各个顶点事件的最早发生时间

   - Ve(1) = 0

   - Ve(3) = 0+2 = 2

   - Ve(2) = 0+3 = 3

   - Ve(5) = 3+2 = 6

   - Ve(4) = max{ Ve(2)+2，Ve(3)+4} = max{5,6} = 6

   - Ve(6) = max{ Ve(5)+1，Ve(4)+2，Ve(3)+3} = max{7,8,5} = 8

![](王道图(一).assets/81.png)



2. 求所有事件的最迟发生事件 Vl()
   - 对AOE网进行逆拓扑排序，根据逆拓扑排序的序列来依次各个顶点事件的最迟发生时间
   - 起点和终点的最早发生时间和最迟发生时间相同 Ve(6) = Vl(6) = 8
   - Vl(5) = 8-1 = 7
   - Vl(4) = 8-2 = 6
   - Vl(2) = min{ Vl(5)-3，Vl(4)-2} = max{4,4} = 4
   - Vl(3) = min{ Vl(4)-4，Vl(6)-3} = max{2,5} = 2
   - Vl(1) = 0

![](王道图(一).assets/82.png)



3. 求所有活动的最早发生时间e()
   - 活动的最早发生时间 = 弧尾所连事件的最早发生时间，e() = Ve()
   - a1活动最早从0开始
   - a2活动最早从0开始
   - a3活动最早从3开始
   - a4活动最早从3开始
   - a5活动最早从2开始
   - a6活动最早从2开始
   - a7活动最早从6开始
   - a8活动最早从6开始



![](王道图(一).assets/83.png)





4. 求所有活动的最迟发生时间 l()
   - V6最晚在8时刻发生，a~8~活动需要1个时间，所以 a~8~ 最晚开始的时间 = 8-1 = 7
   - V5最晚在7时刻发生，a~4~活动需要3个时间，所以 a~4~ 最晚开始的时间 = 7-3 = 4
   - V4最晚在6时刻发生，a~3~活动需要2个时间，所以 a~3~ 最晚开始的时间 = 6-2 = 4
   - V4最晚在6时刻发生，a~5~活动需要4个时间，所以 a~5~ 最晚开始的时间 = 6-3 = 3
   - V3最晚在2时刻发生，a~2~活动需要2个时间，所以 a~2~ 最晚开始的时间 = 2-2 = 0
   - V2最晚在4时刻发生，a~1~活动需要3个时间，所以 a~1~ 最晚开始的时间 = 4-3 = 1



![](王道图(一).assets/84.png)

5. 求所有活动的时间余量 d()
   - d() = 活动最晚发生时间 l() - 活动最早发生时间 e()
   - d(2) = d(5) = d(7) = 0，所以a~2~、a~5~、a~7~ 这几个是关键活动
   - 关键路径为：V1 - V2 - V4 - V6



### 5.6.3、关键活动、关键路径的特性

- 若关键活动耗时增加，则整个工程的工期将增长
- 缩短关键活动的时间，可以缩短整个工程的工期
- 当缩短到一定程度时，关键活动可能会变成非关键活动
- 可能有多条关键路径，只提高一条关键路径上的关键活动速度并不能缩短整个工程的工期，只有加快那些包括在关键路径上的关键活动才能达到缩短工期的目的





### 5.6.4、小结

![](王道图(一).assets/85.png)







































