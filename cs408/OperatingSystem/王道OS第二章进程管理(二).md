

# 1、信号量机制

![](王道OS第二章进程管理(二).assets/1.png)



- 用户进程可以通过使用操作系统提供的**一对原语**来对**信号量**进行操作，从而很方便的实现了进程互斥、进程同步。

- **信号量**其实就是一个变量(可以是一个整数，也可以是更复杂的记录型变量)，可以用一个信号量来**表示系统中某种资源的数量**，比如：系统中只有一台打印机，就可以设置一个初值为1的信号量。

- **原语**是一种特殊的程序段，其**执行只能一气呵成，不可被中断**。原语是由**关中断/开中断**指令实现的。软件解决方案的主要问题是进入区的各种操作无法一气呵成，因此如果能把进入区、退出区的操作都用原语实现，使这些操作能一气呵成就能避免问题。

- **一对原语**：指的是`wait(S)`原语和`signal(S)`原语，可以把原语理解为我们自己写的函数，函数名分别为wait和signal，括号里的**信号量S**其实就是函数调用时传入的一个参数。

- wait、signal 原语常**简称为P、V操作**（来自荷兰语proberen 和verhogen）。因此，做题的时候常把==wait(S)、signal(S) 两个操作分别写为P(S)、V(S)==



## 1.1、整型信号量

用一个**整数型的变量**作为信号量，用来**表示系统中某种资源的数量** (与普通整数变量的区别：普通的整数变量可以进行加减乘除等运行，而信号量的操作只有三种，即**初始化、P操作、V操作**)

```c
int S = 1; //初始化整型信号量S，表示当前系统中可用的打印机资源数

void wait(int S){		// wait原语,相当于"进入区"
    while(S≤0);			// 如果资源数不够,就一直循环等待
    S=S-1;				// 如果资源数够,则占用一个资源
}

void signal(int S){		// signal 原语,相当于"退出区"
    S=S+1;				// 使用完资源后,在退出区释放资源
}

// 进程p0
wait(S);		//进入区,申请资源
使用打印机资源	  //临界区,访问资源
signal(S);		//退出区,释放资源
```

如果有一个进程P0要使用打印机资源,由于这种资源是有限的只有一个，并且我们需要互斥的访问打印机，所以在使用打印机资源之前，进程P0必须要使用一个**wait原语对信号量S进行操作**，wait原语会做两件事情，

- 第一个是判断当前资源数是否足够，如果资源数S≤0，就说明系统当中已经没有这种资源了，那么P0进程就会被一直卡住。但是上述代码中由于P0进程执行wait原语的时候S的值是1，所以不会被卡住，从而执行第二个事 S=S-1=0，也就是说这个打印机资源已经被进程P0使用了，没有其他打印机资源了。

- 当P0在访问打印机资源当中，如果发生了进程切换，有另外的进程P1也想使用打印机资源，那么P1在使用之前**先执行 wait 原语**，不过由于此时S的值已经是0，也就是说系统当中已经没有打印机资源了，所以P1会在执行while循环时卡住。直到P0进程释放打印机资源，执行signal原语使得S值+1，P1才能不被卡住。其他进程若想使用打印机资源与P1相同。

![](王道OS第二章进程管理(二).assets/2.png)

- 因为是用原语来实现的检查和上锁,所以就避免了两个进程同时进入临界区的问题。

> **整型信号量存在的问题**：当进程被卡在while循环时,进程如果获取不到资源,会导致进程一直占用处理机，产生"**忙等**"的情况，并不满足"**让权等待**"的原则。







## 1.2、记录型信号量

整型信号量的缺陷是存在"**忙等**"问题，因此人们又提出了"记录型信号量",即用**记录型数据结构表示的信号量**。

```c
//记录型信号量的定义
typedef struct{
    int value;		// 剩余资源数
    struct process *L;	// 等待队列
}semaphore;

//某进程需要使用资源时，通过wait原语申请
void wait(semaphore S){
    S.value--;
    if(S.value < 0){
        block(S.L);	//如果剩余资源数不够,使用block原语使进程从运行态进入阻塞态，并把进程挂到信号量S的等待队列(即阻塞队列)中
    }
}

// 进程使用完资源后,通过signal原语释放
void signal(semaphore S){
    S.value++;
    if(S.value<=0){
        wakeup(S.L);	// 释放资源后,若还有别的进程在等待这种资源,则使用wakeup原语唤醒等待队列中的一个进程,该进程从阻塞态变为就绪态
    }
}
```

**举个例子**：某计算机系统中有2台打印机,则可在初始化信号量S时将S.value的值设为2，队列S.L设置为空。各个进程在使用打印机资源之前需要使用wait原语来申请打印机资源，在使用打印机资源之后需要使用signal原语来释放打印机资源。

1. 首先p0进程要使用打印机资源，CPU为p0进程服务，使用wait原语来申请打印机资源，在wait原语中,`S.value--`,此时S.value的值变为1，代表剩余打印机数量为1

2. 之后p1进程要使用打印机资源，CPU为p1进程服务，使用wait原语来申请打印机资源，在wait原语中,`S.value--`,此时S.value的值变为0，代表剩余打印机数量为0

3. 之后p2进程要使用打印机资源，CPU为p2进程服务，使用wait原语来申请打印机资源，在wait原语中,`S.value--`,此时S.value的值变为-1，由于`S.value<0`,所以会使用block原语进行自我阻塞(p2进程从**运行态->阻塞态**)，S.value=-1,表示有1个进程在等待

4. 之后p3进程要使用打印机资源，CPU为p3进程服务，使用wait原语来申请打印机资源，在wait原语中,`S.value--`,此时S.value的值变为-2，由于`S.value<0`,所以会使用block原语进行自我阻塞(p3进程从**运行态->阻塞态**)，S.value=-2,表示有2个进程在等待

5. p0使用完打印机资源之后会执行 signal 原语,在signal原语中，`S.value++`，此时S.value的值变为-1，由于`S.value≤0`,所以会使用wakeup原语唤醒等待队列中的第一个进程(被唤醒进程从**阻塞态->就绪态**),也就是p2进程被唤醒，CPU为p2进程服务，并且将p0进程释放的打印机资源给p2进程使用

---

- 在考研题目中wait(S),signal(S)也可以记为P(S)、V(S)，这对原语可用于**实现系统资源的申请和释放。**

- `S.value` 的初值表示系统中**某种资源的题目**。
- 对信号量S的一次**P操作**意味着进程**请求一个单位的该类资源**，因此需要执行S.value--，表示资源数减1，当S.value<0时表示该类资源已分配完毕,因此进程应调用block原语进行自我阻塞(当前运行的进程从运行态->阻塞态)，主动放弃处理机，并插入该类资源的等待队列S.L中。可见，该机制遵循了"让权等待"原则，不会出现"忙等"现象。
- 对信号量S的一次**V操作**意味着进程**释放一个单位的该类资源**，因此需要执行S.value++，表示资源数加1，若加1后仍是S.value<=0,表示依然有进程在等待该类资源，因此应调用wakeup原语唤醒等待队列中的第一个进程（被唤醒进程从阻塞态->就绪态）



## 1.3、小结

![](王道OS第二章进程管理(二).assets/3.png)





# 2、信号量机制的实现

![](王道OS第二章进程管理(二).assets/4.png)

- 一个信号量对应一种资源
- 信号量的值 = 这种资源的剩余数量(信号量的值如果小于0，说明此时有进程在等待这种资源)
- P(S)-申请一个资源S,**如果资源不够就阻塞等待**
- V(S)-释放一个资源S,如果有进程在等待该资源,**则唤醒一个进程**





## 2.1、信号量机制实现进程互斥

系统当中的某些资源，是必须互斥访问的，而**访问这种资源的代码叫做临界区**。

1. 分析并发进程的关键活动，划定临界区(如：对临界资源打印机的访问就应放在临界区)
2. 设置**互斥信号量**mutex,**初值为1**
3. 在进入区P(mutex)--申请资源
4. 在退出区V(mutex)--释放资源

```c
//记录型信号量的定义
typedef struct{
    int value;		//剩余资源数
    struct process *L;	//等待队列
}semaphore;
```

我们自己要会定义记录型信号量，但是如果题目中没有特别-说明，则我们可以把信号量的声明简单写成下 `semaphore mutex`

```c
// 信号量机制实现互斥
semaphore mutex=1 //初始化信号量(默认是记录型信号量)
    
P1(){
    P(mutex);		//使用临界资源前需要加锁
    临界区代码段...
    V(mutex);		//使用临界资源后需要解锁
}

P2(){
    P(mutex);		//使用临界资源前需要加锁
    临界区代码段...
    V(mutex);		//使用临界资源后需要解锁
}
```

- 当一个进程进入临界区之前，需要执行 P(mutex) ，出了临界区之后需要执行 V(mutex)，这样就可以实现进程对临界区代码的互斥访问。
- 我们可以认为信号量 mutex 表示的是 **进入临界区的名额**，初值为1，表示刚开始进入临界区的名额只有1个，当进程P1执行 P(mutex) 其实就是**申请一个进入临界区的名额**，如果这种名额还有余量，则进程P1可以顺利进入临界区。如果此时进程P2执行 P(mutex) 申请名额，因为名额为0，所以会阻塞等待。直到进程P1执行 V(mutex) **归还名额**，这个时候P2进程会被唤醒进入临界区。

==注意==：

1. **对不同的临界资源需要设置不同的互斥信号量**。例如临界区资源为打印机和摄像头，则必须为打印机和摄像头分别设置互斥信号量mutex1和mutex2

2. **P、V操作必须成对出现**。缺少P(mutex)就不能保证临界资源的互斥访问。缺少V(mutex)会导致资源永不被释放，导致等待的进程永不被唤醒。





## 2.2、信号量机制实现进程同步

**进程同步**：要让各并发进程按照要求的顺序有序地推进。

![](王道OS第二章进程管理(二).assets/5.png)

怎么用信号量机制实现进程同步：

1. 分析什么地方需要实现"同步关系"，即必须保证"**一前一后"**执行的两个操作(某一句代码必须要在前，某一句代码必须要在后)
2. 设置**同步信号量**S，**初始为0**
3. **在"前操作"之后执行V(S)**
4. **在"后操作"之前执行P(S)**


如下图，代码2必须在前执行,代码4必须在后执行，所以代码2是"前操作",代码4是"后操作"，所以在前操作代码2之后执行V操作,在后操作代码4之前执行P操作。

![](王道OS第二章进程管理(二).assets/6.png)

> 技巧口诀：前V后P



​	





## 2.3、信号量机制实现前驱关系

进程P1中有句代码S1，P2中有句代码S2.....,P3中有句代码S6。这些代码要求按如下前驱图所示的顺序来执行。

![](王道OS第二章进程管理(二).assets/7.png)



这个前驱图的意思是，只有S1这一句代码执行了之后，才可以执行S2这一句代码，而只有S2执行了代码之后，才可以执行S4和S5这两句代码。只有S4、S5、S3执行之后，才可以执行S6。

其实每一对前驱关系都是一个进程同步问题(需要保证一前一后的操作)。因此：

1. 要**为每一对前驱关系各设置一个同步信号量**(设置a、b、c、d、e、f、g为同步信号量，并且同步信号量的初值都为0，也就是说这种资源刚开始是没有的，这种资源只能由前面的进程的V操作产生)
2. **在"前操作"之后对相应的同步信号量设置V操作**(S1在前，S2在后，所以S1为前操作，S2为后操作，在S1之后执行V操作，在S2之前执行P操作)
3. **在"后操作"之前对相应的同步信号量变量执行P操作**(S1在前，S2在后，所以S1为前操作，S2为后操作，在S1之后执行V操作，在S2之前执行P操作)

![](王道OS第二章进程管理(二).assets/8.png)

> 前V后P

S1要在S2之前执行，所以S1之后要执行V操作,S2要在之前执行P操作

S1要在S3之前执行，所以S1之后要执行V操作,S3要在之前执行P操作

---

上述各个进程以不同的顺序上处理机运行，可以实现同步。例如P5上处理机，执行P(d)，而由于d初值为0，所以P5进程会阻塞在这里，接下来发生进程调度，假设切换为P2上处理机，执行P(a)，而由于a初值为0，所以P2进程会阻塞在这里，接下来发生进程调度，假设切换为P1上处理机，执行S1、V(a)、V(b)，V(a)会唤醒P2进程，所以接下来P2进程才会执行S2代码，也就是说S2肯定是在S1之后执行的，这样就实现了进程同步。







## 2.4、小结

![](王道OS第二章进程管理(二).assets/9.png)







# 3、进程同步互斥问题



## 3.1、生产者消费者问题

系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区取出一个产品并使用。(注：这里的"产品"理解为某种数据)，**生产者、消费者共享一个初始为空、大小为n的缓冲区。**

- 只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须阻塞等待。(缓冲区没满->生产者生产，这是一前一后)
- 只有缓冲区不空时，消费者才能从中取出产品，否则必须阻塞等待(缓冲区没空->消费者消费，这是一前一后)
- 缓冲区是临界资源，各进程必须互斥的访问(互斥关系)
  - 若进程并发的运行，两个生产者进程并发的写入缓冲区，缓冲区又是有限的，难免出现数据覆盖，**所以缓冲区才是临界资源，各个进程才要互斥的访问**。


![](王道OS第二章进程管理(二).assets/10.png)



- 第一个关系是只有当缓冲区里有产品的时候，消费者进程才可以消费；第二个关系是只有缓冲区没满的时候，生产者进程才可以生产。所以这两个一前一后的关系我们就需要给他们**设置同步信号量**full、empty，并且在前面的操作完成之后对同步信号量执行V操作，在后面的操作完成之前对同步信号量执行P操作。
- 除了上述两对一前一后的关系外，还要实现对临界区的互斥访问，所以还需要**设置互斥信号量**mutex，让其初值为1，在临界区的前面和后面分别执行P、V操作即可。

---

PV操作题目分析步骤：

1. 关系分析。找出题目中描述的各个进程，分析它们之间的同步、互斥关系
   - 缓冲区没满->生产者生产   => 一前一后同步关系
   - 缓冲区没空->消费者消费   => 一前一后同步关系
   - 缓冲区是临界区                  => 互斥访问互斥关系 
2. 整理思路。根据各进程的操作流程确定P、V操作的大致顺序。
3. 设置信号量。并根据题目条件确定信号量初值。(**互斥信号量初值一般为1，同步信号量的初始值要看对应资源的初始值是多少**)

---

- 消费者进程在消费之前，需要消耗产品资源，所以在它之前的P操作其实是在申请一个产品，因此full同步信号量它所对应的资源是**产品的数量**，也就是**非空缓冲区的数量**，而题中刚开始产品的数量是0，所以full初始值为0

- 生产者每生产一个产品就需要消耗一个空闲缓冲区，因此 empty 这个同步信号量它所对应的资源就应该是空闲缓冲区这种资源，它的数量就是**空闲缓冲区的数量**，题目中的空闲缓冲区的数量为n，所以empty初始值为n

```c
semaphore mutex = 1;		// 互斥信号量,实现对缓冲区的互斥访问
semaphore empty = n;		// 同步信号量,表示空闲缓冲区的数量
semaphore full = 0;			// 同步信号量,表示产品的数量,也即非空缓冲区的数量

// 生产者
producer(){
    while(1){
        生产一个产品;
        P(empty);		//消耗一个空闲缓冲区
        P(mutex);		
        把产品放入缓冲区
        V(mutex);
        V(full);		//增加一个产品
    }
}

// 消费者
consumer(){
    while(1){
        P(full);		//消耗一个产品(非空缓冲区)
        P(mutex);		
        从缓冲区取出一个产品;
        V(mutex);
        V(empty);		//增加一个空闲缓冲区
        使用产品;
    }
}
```

![](王道OS第二章进程管理(二).assets/11.png)

生产者要做的就是不断的生产一个产品，然后把产品放入缓冲区。消费者要做的就是不断的从缓冲区取出一个产品并使用。生产者在把产品放入缓冲区之前，需要申请一个空闲的缓冲区，所以需要在放入缓冲区之前执行`P(empty)`操作，在把产品放入缓冲区之后，执行`V(full)`操作,表示增加了一个产品。消费者在从缓冲区取走一个产品之前，需要消耗一个产品，执行`P(full)`操作，而当它取走一个产品之后，空闲缓冲区的数量会+1,执行`V(empty)`

因为缓冲区必须互斥的访问，所以在访问缓冲区前后分别要对 `mutex` 这个互斥信号量执行P和V操作。

> 实现互斥是在同一进程中进行一对PV操作。
>
> 实现两进程的同步关系，是在其中一个进程中执行P，另一个进程中执行V。











### 3.1.1、思考

我们可以思考一下，能否改变相邻P、V操作的顺序？

![](王道OS第二章进程管理(二).assets/12.png)



1. 若此时缓冲区内已经放满产品，则empty=0，full=n。则生产者进程执行① 使mutex变为0，再执行②，由于已没有空闲缓冲区，因此生产者被阻塞。

2. 由于生产者阻塞，因此切换回消费者进程。消费者进程执行③，由于mutex为0，即生产者还没释放对临界资源的“锁”，因此消费者也被阻塞。

3. 这就造成了生产者等待消费者释放空闲缓冲区，而消费者又等待生产者释放临界区的情况，生产者和消费者循环等待被对方唤醒，出现“死锁”。

4. 同样的，若缓冲区中没有产品，即full=0，empty=n。按③④① 的顺序执行就会发生死锁。

> 实现互斥的P操作一定要在实现同步的P操作之后。即P(empty)在前，P(mutex)在后
>
> V操作不会导致进程阻塞，因此两个V操作顺序可以交换。

![](王道OS第二章进程管理(二).assets/13.png)



## 3.2、多生产者多消费者问题

桌子上有一只盘子，每次只能向其中放入一个水果。爸爸专向盘子里放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。只有盘子空时，爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。用PV操作实现上述过程。

![](王道OS第二章进程管理(二).assets/14.png)





我们把盘子看作大小为1，初始为空的缓冲区。将父亲母亲看作是两个生产者进程，将儿子女儿看作是两个消费者进程。

1. 关系分析。找出题目中描述的各个进程，分析它们之间的同步、互斥关系。

   - 进程有4个，父亲、母亲、儿子、女儿。

   - 互斥关系(mutex=1)：对缓冲区(盘子)的访问要互斥地进行

   - 同步关系(一前一后)：

     - 父亲将苹果放入盘子后，女儿才能取苹果

     - 母亲将橘子放入盘子后，儿子才能取橘子

     - 只有盘子为空时，父亲或者母亲才能放入水果。(盘子为空这个事件可以由儿子或女儿触发，事件发生后才允许父亲或母亲放水果)

2. 整理思路。根据各进程的操作流程确定P、V操作的大致顺序。(**互斥：在临界区前后分别PV。同步：前V后P**)

3. 设置信号量。设置需要的信号量，并根据题目条件确定信号量初值。(互斥信号量初值一般为1，同步信号量的初始值要看对应资源的初始值是多少)。

![](王道OS第二章进程管理(二).assets/15.png)

分别设置 apple、orange、plate 同步信号量。

```c
semaphore mutex = 1;		// 实现互斥访问盘子(缓冲区)
semphore apple = 0;			// 盘子中有几个苹果
semaphore orange = 0;		// 盘子中有几个橘子
semphore plate = 1;			// 盘子中还可以放多少个水果

dad(){
    while(1){
        准备一个苹果;
        P(plate);
        P(mutex);
        把苹果放入盘子;
        V(mutex);
        V(apple);
    }
}

mom(){
    while(1){
        准备一个橘子;
        P(plate);
        P(mutex);
        把橘子放入盘子;
        V(mutex);
        V(orange);
    }
}

daughter(){
    while(1){
        P(apple);
        P(mutex);
        从盘子中取出苹果;
        V(mutex);
        V(plate);
        吃掉苹果;
    }
}

son(){
    while(1){
        P(orange);
        P(mutex);
        从盘子中取出橘子;
        V(mutex);
        V(plate);
        吃掉橘子;
    }
}
```

- 父亲进程和母亲进程需要做的就是准备一个苹果/橘子，然后将苹果/橘子放入盘子，女儿和儿子只需要从盘子中取出苹果/橘子，然后吃掉。

- 父亲进程在放入苹果之前，需要先检查这个盘子是否为空，所以在把苹果放入盘子之前，需要进行 `P(plate)` 来检查盘子中还可以放多少个水果，将苹果放入盘子之后，需要执行 `V(apple)` 操作来让 apple 的值加1，来告诉女儿进程此时盘子中的苹果数量已经加1了。

- 母亲进程在放入橘子之前，需要先检查这个盘子是否为空，所以在把橘子放入盘子之前，需要进行 `P(plate)` 来检查盘子中还可以放多少个水果，若盘子中已有水果，则母亲进程被阻塞。若盘子中没有水果，母亲将橘子放入盘子之后，需要执行`V(orange)`操作来让 orange 的值加1，来告诉儿子进程此时盘子中的橘子数量已经加1了。

- 女儿进程在取出苹果之前要判断盘子中是否有自己喜欢的水果，所以在取出苹果之前执行`P(apple)` 操作来检查是否已经有苹果，在女儿将苹果从盘子中取出之后，需要执行`V(plate)` 操作来告诉父亲/母亲进程此时盘子已经变空了。

- 儿子进程和女儿进程类似，只是检查的时候检查的是橘子。

- 我们还需要对盘子这个缓冲区进行互斥访问，所以在访问盘子之前`P(plate)`执行`P(mutex)` 操作,在访问盘子之后执行`V(mutex)`操作。

---

这个题即使不设置专门的互斥信号量mutex,也不会出现多个进程同时访问盘子的现象，因为本题中的缓冲区大小为1，在任何时刻，apple、orange、plate三个同步信号量中最多只有一个是1。因此在任何时刻，最多只有一个进程的P操作不会被阻塞，并顺序地进入临界区。

> 因此，如果在生产者消费者问题中遇到了缓冲区大于1，就必须专门设置一个互斥信号量mutex来保证互斥访问缓冲区

总结：在生产者-消费者问题中，如果缓冲区大小为1，那么**有可能**不需要设置互斥信号量就可以实现互斥访问缓冲区的功能。这不是绝对的，在考试中如果来不及仔细分析，可以加上互斥信号量，保证各进程一定会互斥地访问缓冲区。但需要注意的是，**实现互斥的P操作一定要在实现同步的P操作之后，否则可能引起死锁。**

### 3.2.1、小结

解决"多生产者-多消费者问题"的关键在于理清复杂的同步关系。在分析同步问题（一前一后问题）的时候不能从单个进程行为的角度来分析，要把“一前一后”发生的事看做是两种“事件”的前后关系。

比如，如果从单个进程行为的角度来考虑的话，我们会有以下结论：

- 如果盘子里装有苹果，那么一定要女儿取走苹果后父亲或母亲才能再放入水果
- 如果盘子里装有橘子，那么一定要儿子取走橘子后父亲或母亲才能再放入水果

这么看是否就意味着要设置四个同步信号量分别实现这四个"一前一后"的关系了？正确的分析方法应该从"事件"的角度来考虑，我们可以把上述四对"进程行为的前后关系"抽象为一对"事件的前后关系"。**盘子变空事件一定要在放入水果事件之前。**

- "盘子变空事件"既可由儿子引发，也可由女儿引发；
- "放水果事件"既可能是父亲执行，也可能是母亲执行。

这样的话，就可以用一个同步信号量解决问题了。

![](王道OS第二章进程管理(二).assets/16.png)



## 3.3、吸烟者问题

假设一个系统有**三个抽烟者进程**和**一个供应者进程**。每个抽烟者不停的卷烟并抽掉它，但是要卷起并抽掉一支烟，抽烟者需要有三种材料：烟草、纸和胶水。三个抽烟者中，第一个拥有烟草、第二个拥有纸、第三个拥有胶水。供应者进程无限地提供三种材料，供应者每次将两种材料放桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉完成了，供应者就会放另外两种材料在桌上，这个过程一直重复(让三个抽烟者轮流的抽烟)

![](王道OS第二章进程管理(二).assets/17.png)

本质上这个题也属于生产者-消费者问题，更详细的说应该是**可生产多种产品的单生产者-多消费者**。

1. 关系分析。找出题目中描述的各个进程，分析它们之间的同步、互斥关系。·
   - **桌子可以抽象为容量为1的缓冲区，要互斥访问**。
     - 组合一：纸+胶水
     - 组合二：烟草+胶水
     - 组合三：烟草+纸
     - 这里我们不应该把材料看作独立的物品，而是应该把两种材料看成一种组合
   
   - **同步关系**
     - 桌子上有组合一 -> 第一个抽烟者取走东西(一前一后)
     - 桌子上有组合二 -> 第二个抽烟者取走东西(一前一后)
     - 桌子上有组合三 -> 第三个抽烟者取走东西(一前一后)
     - 发出完成信号 -> 供应者将下一个组合放到桌上

2. 整理思路。根据各进程的操作流程确定P、V操作的大致顺序。
   - **对于实现互斥很简单：在访问临界资源之前和之后执行P、V操作**
   - **对于实现同步：我们需要遵循前V后P这样的原则**
     - 前操作之后执行V操作
     - 后操作之前执行P操作

3. 设置信号量，设置需要的信号量，并根据题目条件确定信号量初值。(**互斥信号量初值一般为1，同步信号量的初始值要看对应资源的初始值是多少**)
   - 桌上有组合一必须在第一个抽烟者取走东西之前，所以对于这一对同步关系来说，我们需要为它设置一个同步信号量 offer1，刚开始桌子上是没有组合一的，所以**同步信号量**offer1 = 0。(**前V后P**)
     - 同理，设置信号量 offer2=0、offer3=0
   - 发出完成信号必须在供应者将下一个组合放到桌上之前，发出完成信号可以由3个抽烟者任何一个触发，刚开始并没有任何一个抽烟者发出完成信号，所以**同步信号量** finish = 0。

![](王道OS第二章进程管理(二).assets/18.png)

供应者每次在桌上放了某种组合之后，都需要执行+1并且对3取余操作，每个循环都会使 i 的值变为0、1、2这样循环，若 i 的值为0，则供应者就把组合1放到桌上，也就是让第一个吸烟者吸烟，这样就可以实现让三个吸烟者轮流吸烟的事情。

当供应者在桌子上放入某种组合之后，它需要对这种组合对应的同步信号量执行`V(offer)`操作，用来通知等待这种组合的吸烟者。

供应者把材料放到桌上之后，它需要等待抽烟者发出完成信号，所以执行 `P(finish)` 操作。

各个吸烟者在从桌子上拿走材料之前，需要先检查桌子上的组合是不是自己需要的材料，所以执行`P(offer)`操作

当吸烟者把材料拿走并且卷烟抽掉之后，又需要向供应者发出一个完成信号来通知供应者可以开始放下一组材料，所以需要执行`V(finish)`

由于刚开始 finish 为0，所以开始供应者会在执行 `P(finish)` 操作被阻塞，直到第一个抽烟者执行 `V(finish)` 操作之后，供应者进程才会从阻塞态回到就绪态，然后进行下一轮的供给。

![](王道OS第二章进程管理(二).assets/19.png)



```c
semaphore offer1 = 0;		// 桌上组合一的数量
semaphore offer2 = 0;		// 桌上组合二的数量
semaphore offer3 = 0;		// 桌上组合三的数量
semaphore finish = 0;		// 抽烟是否完成
int i = 0; 					// 用于实现"三个抽烟者轮流抽烟"


provider(){
    while(1){
        if(i==0){
            将组合一放桌上;
            V(offer1);		// 通知等待这种组合的吸烟者
        }else if(i==1){
            将组合二放桌上;
            V(offer2);		// 通知等待这种组合的吸烟者
        }else if(i==2){
            将组合三放桌上;
            V(offer3);		// 通知等待这种组合的吸烟者
        }
        i = (i+1)%3;
        P(finish);			// 等待吸烟者发出吸烟的信号
    }
}


smoker1(){
    while(1){
        P(offer1);				// 检查桌子上的组合
        从桌子上拿走组合一;卷烟;抽掉;
        V(finish);				// 发出完成信号,通知供应者释放下一组材料
    }
}

smoker2(){
    while(1){
        P(offer2);		
        从桌子上拿走组合二;卷烟;抽掉;
        V(finish);
    }
}

smoker3(){
    while(1){
        P(offer3);		
        从桌子上拿走组合三;卷烟;抽掉;
        V(finish);
    }
}
```



### 3.3.1、小结

吸烟者问题可以为我们解决 "可以生产多个产品的单生产者"问题提供一个思路。值得吸取的精华是："轮流让各个吸烟者吸烟" 必然需要 "轮流的在桌上放上组合一、二、三"，注意体会我们是如何让一个整型变量 i 实现这个 "轮流" 过程的。

若一个生产者要生产多种产品(或者说会引发多种前驱事件)，那么各个V操作应该放在各自对应的 "事件" 发生之后。



## 3.4、读者写者问题

有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程(读进程或写进程)同时访问共享数据时可能导致数据不一致的错误。因此要求：

1. 允许多个读者可以同时对文件执行读操作。(因为读是不会改变数据，所以多个读者可同时访问数据)
2. 只允许一个写者往文件中写信息。
3. 任一写者在完成写操作之前不允许其他读者或写者工作。
4. 写者执行写操作前，应让已有的读者和写者全部退出

![](王道OS第二章进程管理(二).assets/44.png)

1. 关系分析。找出它们之间的同步、互斥关系。

   - 两类进程：写进程、读进程

   - 互斥关系：写进程和写进程互斥、写进程和读进程互斥。读进程和读进程不存在互斥关系。

2. 整理思路，根据各进程的操作流程确定P、V操作的大致顺序

3. 设置信号量。设置需要的信号量，并根据题目条件确定信号量初值。(互斥信号量初值一般为1，同步信号量的初始值要看对应资源的初始值是多少)

```c
semphore rw=1;		// 用于实现对共享文件的互斥访问
int count = 0;		// 记录当前有几个读进程在访问文件
semaphore mutex = 1;	// 用于保证对 count 变量的互斥访问

writer(){
    while(1){
        P(rw);		// 写之前先"加锁"
        写文件;
        V(rw);		// 写完了"解锁"
    }
}

reader(){
    while(1){
        P(mutex);		//	各读进程互斥访问count
        if(count==0){	// 由第一个读进程负责
            P(rw);			// 读之前"加锁"
        }
        count++;		// 访问文件的读进程数+1
        V(mutex);		
        读文件;
        P(mutex);		// 各读进程互斥访问count
        count--;		// 访问文件的读进程数-1
        if(count==0){	// 由最后一个读进程负责
            V(rw);		// 读完了"解锁"
        }  
    }
}
```

![](王道OS第二章进程管理(二).assets/43.png)

我们设置`rw`的互斥信号量用于实现各个进程对于共享文件的互斥访问。

- 写者进程要做的就是不断的写文件，而读者进程就是不断的读文件，由于写者和读者之间需要互斥的访问文件这个共享资源，所以写者在写文件之前需要执行`P(rw)`操作加锁文件，在写完文件之后执行`V(rw)`操作解锁文件。读者在读文件之前需要执行`P(rw)`操作加锁文件，在读完文件之后执行`V(rw)`操作解锁文件，这样就可以实现读者和写者之间互斥的访问这个文件。
- 如果我们只是简单的在读文件之前加锁，读完文件解锁。这种方案会导致读者和读者之间不可以同时访问文件，所以我们加入count 信号量，count 记录当前有几个读进程正在访问文件。`coutn`初始值是0，意味着刚开始并没有读进程在读这个文件。所以当读进程在进行`P(rw)`加锁之前会进行检查，检查自己是不是第一个想要读这个文件的进程，如果自己是第一个读进程的话，那么就会执行`P(rw)`操作加锁。
- 之后执行 `count++` 操作表示当前正在访问文件的读进程数+1，而当一个读进程读完文件之后它需要对访问文件的读进程数 `count--` 操作表示此时访问文件的读进程数-1，之后再对count的值进行判断，如果 count 的值变为了0那么就说明此时没有别的读进程正在读这个文件，所以需要对文件进行解锁`V(rw)`。这样就可以实现读进程和读进程之间同时读文件，因为只有第一个读进程才需要对这个文件进行加锁，才会执行`P(rw)`操作，而只要此时 `count>0` ，接下来读进程就不会执行 `P(rw)`再次加锁，可以直接跳过`if(count==0)`条件判断，直接进行`count++`操作。
- **由第一个读进程负责加锁，由最后一个读进程负责解锁。**
- 这种方案也有一个潜在问题：若两个读进程并发执行，则count=0时两个进程也许都满足if条件，都会执行`P(rw)`，从而使第二个读进程阻塞的情况，如何解决：出现上述问题的原因在于对count变量的检查和赋值无法一气呵成，因此可以设置另一个互斥信号量mutex=1来保证各读进程对count的访问是互斥的。在对`count`操作之前执行`P(mutex)`上锁操作使得mutex的值为-1，对`count`操作之后执行`V(mutex)`操作使mutex的值+1。
- 这样即使两个读进程并发执行，第一个读进程执行`P(mutex)`之后使得mutex的值为0，第二个都进程在执行`P(mutex)`会被阻塞在这里。同一时刻只有一个读进程对`count`进行操作。
- **潜在的问题**：只要有读进程还在读，写进程就要一直阻塞等待，可能"饿死"。假设有一个读进程正在读文件，读之前会`P(rw)`加锁，并且`count++`使得count的值是1，而此时如果有一个写进程到达，由于读进程已经执行`P(rw)`加锁，`rw=0`，因此写进程会阻塞在 `P(rw)`操作上。有源源不断的读进程，写进程就不会执行。这种算法中，读进程是优先的。

---

分析：假设此时有一个读进程正在读文件，那么此时 count 的值是1，此时如果有写进程到达的话，因为第一个读进程已经执行了`P(rw)`加锁操作，rw的值为0，所以写进程会一直卡在`P(rw)`这里，但是此时如果有另一个读进程到来，由于count的值为1，所以会跳过检查 count 的值，从而直接执行读文件的操作，如果有源源不断的读进程到来的话，那么都可以跳过检查count的值，都可以开始读文件，由于只有最后一个读进程读完文件之后执行`V(rw)`操作解锁，所以写进程可能会一直阻塞。

解决方法如下：

```c
semphore rw=1;		// 用于实现对共享文件的互斥访问
int count = 0;		// 记录当前有几个读进程在访问文件
semaphore mutex = 1;	// 用于保证对 count 变量的互斥访问
sempahore w = 1;		// 用于实现写优先


writer(){
    while(1){
        P(w);
        P(rw);		// 写之前先"加锁"
        写文件;
        V(rw);		// 写完了"解锁"
        V(w);
    }
}

reader(){
    while(1){
        P(w);
        P(mutex);		//	各读进程互斥访问count
        if(count==0){	// 由第一个读进程负责
            P(rw);			// 读之前"加锁"
        }
        count++;		// 访问文件的读进程数+1
        V(mutex);
        V(w);
        读文件;
        P(mutex);		// 各读进程互斥访问count
        count--;		// 访问文件的读进程数-1
        if(count==0){	// 由最后一个读进程负责
            V(rw);		// 读完了"解锁"
        }  
    }
}
```

![](王道OS第二章进程管理(二).assets/45.png)



- 再设置一个互斥信号量w，这个信号量用于实现写优先。

- 例如有两个读者进程并发运行，第一个读进程在检查 `if(count==0)` count 值的时候发生了进程调度，第二个读进程会在`P(w)`阻塞，直到第一个读进程执行了`V(w)`操作，第二个读进程才有可能被唤醒，并且第二个读进程不需要判断 count 的值，所以这样就可以保证两个读进程可以同时读文件。

- 例如有两个写进程并发运行，第一个写进程在执行`P(w)`和`P(rw)`之后，w和rw的值都为0，所以第二个写进程会被阻塞在`P(w)`这个互斥信号量这，直到第一个写进程写完文件之后执行`V(w)`和`V(rw)`之后，第二个写进程才有可能来写这个文件。所以两个写进程并发运行可以实现互斥的写文件。

- 例如有一个写进程在运行，执行`P(w)`之后w的值为0，此时发生进程调度，读进程运行会被卡在`P(w)`处，直到写进程执行了`V(w)`之后，读进程才有可能进行读文件，所以读者和写者之间互斥访问这个文件。

- 例如有一个读进程在运行，执行一系列操作后读文件，由于读进程在读文件之前执行`P(w)`和`V(w)`，因此在读进程读文件时w=1，并且读进程还执行了`P(rw)`使得rw=0，此时切换回写者进程，由于w=1所以`P(w)`不会被阻塞，所以使得rw=0，但是写进程在执行`P(rw)`时由于rw=0所以写进程会被阻塞。第二个读进程此时也上处理机，由于w=0所以在执行`P(w)`会被阻塞。所以写者和第二个读者都会被阻塞。当第一个读进程读文件完成执行`count--`使得count=0，所以还会执行`V(rw)`使得rw=1，这样就会唤醒被阻塞的写进程。
- 假设有一个写者进程在运行，写者在写文件时w=0，rw=1。此时有一个读者上处理机运行，由于w=0所以会被阻塞在`P(w)`。此时还有第二个写者进程上处理机运行，也会由于w=0而阻塞在`P(w)`。之前说过信号量除了表示资源还表示排队，由于读进程先对信号量执行`P(w)`操作，所以会排在w信号量队列之后，而第二个写者进程后执行`P(w)`，所以它会排在读者进程之后。所以当第一个写者写完文件并且执行`V(w)`之后使得w=1，首先唤醒的是读者进程。

**结论**：在这种算法中，连续进入的多个读者可以同时读文件；写者和其他进程不能同时访问文件；写者不会饥饿，但也并不是真正的"写优先",而是相对公平的先来先服务原则。

读者-写者问题为我们解决复杂的互斥问题提供了一个参考思路。其**核心思想**在于设置了一个**计数器count**用来记录当前正在访问共享文件的读进程数。我们可以用count的值来判断当前进入的进程是否是第一个/最后一个读进程，从而做出不同的处理。另外，对count变量的检查和赋值不能一气呵成导致了一些错误，**如果需要实现"一气呵成"，自然应该想到用互斥信号量。**



## 3.5、哲学家进餐问题

一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭。哲学家们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时，才试图拿起左、右两根筷子（一根一根地拿起）。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。

![](王道OS第二章进程管理(二).assets/46.png)



1. 关系分析。系统中有5个哲学家进程，5位哲学家与左右邻居对其中间筷子的访问是互斥关系。
2. 整理思路。这个问题中只有互斥关系，但与之前遇到的问题不同的是，每个哲学家进程需要同时持有两个临界资源才能开始吃饭。如何**避免**临界资源分配不当造成的**死锁现象**，是哲学家问题的精髓。
3. 信号量设置。定义互斥信号量数组 chopstick[5]={1,1,1,1,1} 用于实现对5个筷子的互斥访问。我们对5支筷子编号0~4，并对哲学家按 0~4 编号，哲学家i左边的筷子编号为i，和它自身编号相同，右边的筷子编号位 (i+1)%5。

如何防止死锁的发生呢？

> 仅当一个哲学家左右两支筷子都可用时才允许他抓起筷子。

```c
semaphore chopstick[5]={1,1,1,1,1};
semaphore mutex = 1;		// 互斥地取筷子
Pi(){
    while(1){
        P(mutex);
        P(chopstick[i]);	//拿左
        P(chopstick[(i+1)%5]);//拿右
        V(mutex);
        吃饭;
        V(chopstick[i]);		// 放左
        V(chopstick[(i+1)%5]);	// 放右
        思考;
    }
}
```

可以设置一个互斥信号量 mutex,可以在哲学家拿筷子之前和拿筷子之后分别执行`P(mutex)`和`V(mutex)` 操作。

- 假设0号哲学家要吃饭拿筷子，mutex初始值为1，先执行`P(mutex)`使mutex值为0，然后执行`P(chopstick[i])` 拿到左边的筷子，假如此时发生进程调度，2号哲学家要吃饭拿筷子，因为此时mutex=0执行`P(mutex)`会被阻塞，直到0号哲学家执行`V(mutex)`操作之后，才会唤醒2号哲学家。

- 假设0号哲学家要吃饭拿筷子，mutex初始值为1，先执行`P(mutex)`使mutex值为0，然后执行`P(chopstick[i])` 拿到左边的筷子，继续`P(chopstick[i+1]%5)`拿到右边的筷子，再执行`V(mutex)`使得mutex值为1，0号哲学家开吃。若此时1号哲学家也想吃饭，由于mutex=1所以1号哲学家在执行`P(mutex)`时不会被阻塞使得mutex=0，但是在执行`P(chopstick[i])` 拿左边的筷子时会发生阻塞。若此时2号哲学家也想吃饭，由于mutex=0所以会阻塞在`P(mutex)`。在这种情况下，即使2号哲学家左右两边的筷子都没被用，但是它依然拿不了左右两边的筷子。
- 假设0号哲学家要吃饭拿筷子，mutex初始值为1，先执行`P(mutex)`使mutex值为0，然后执行`P(chopstick[i])` 拿到左边的筷子，继续`P(chopstick[i+1]%5)`拿到右边的筷子，再执行`V(mutex)`使得mutex值为1，0号哲学家开吃。若此时4号哲学家也想吃饭，由于mutex=1所以1号哲学家在执行`P(mutex)`时不会被阻塞使得mutex=0，在执行`P(chopstick[i])` 拿左边的筷子时因为没人用也可以拿起来，但是右边筷子被0号哲学家拿了，所以4号哲学家会阻塞在`P(chopstick[i+1]%5)`。因此虽然4号右边筷子不能用，但4号哲学家仍会拿左边的筷子

因此这种方法并不能保证只有两边的筷子都可用时才允许哲学家拿起筷子，即使某个哲学家两边的筷子其中一边不能用时，这个哲学家依然可以拿起另一只筷子。更准确的说法应该是：各哲学家拿筷子这件事必须互斥的执行。这就保证了即使一个哲学家在拿筷子拿到一半时被阻塞，也不会有别的哲学家会继续尝试拿筷子。这样的话，当前正在吃饭的哲学家放下筷子后，被阻塞的哲学家就可以获得等待的筷子了。

---

哲学家进餐问题的关键在于解决进程死锁。这些进程之间只存在互斥关系，但是与之前接触到的互斥关系不同的是，每个进程都需要同时持有两个临界资源，因此就有**死锁**问题的隐患。如果在考试中遇到了一个进程需要同时持有多个临界资源的情况，应该参考哲学家问题的思想，分析题中给出的进程之间是否会发生循环等待，是否会发生死锁。







# 4、管程

![](王道OS第二章进程管理(二).assets/20.png)





## 4.1、为什么要引入管程

信号量机制存在的问题：编写程序困难、易出错。而管程是一种**高级同步机制**，可以解决这个问题。让程序员写程序时不需要再关注复杂的PV操作，让写代码更轻松。**管程的本质也是用于实现进程的互斥同步的。**

## 4.2、管程的定义和基本特征

管程和之前学过的P、V操作一样，也是用来实现进程的互斥和同步的，而进程之间要实现互斥和同步，是因为进程之间可能会共享某些资源。比如说生产者和消费者问题当中，生产者和消费者都需要共享的访问缓冲区这种资源，所以为了实现进程对某些资源同步或者互斥的访问，管程就要由如下部分组成：

管程是一种特殊的软件模块，**由这些部分组成**：

1. 局部于管程的**共享数据结构**说明(比如生产者消费者模型里面的缓冲区)
2. 对该数据结构进行操作的**一组过程**(过程其实就是函数)
3. 对局部于管程的共享数据设置初始值的语句(也就是对管程进行初始化的一些语句)
4. 管程有一个名字

> 管程的定义有点像我们面向对象的类，在类当中定义一些数据，并且可以定义对这些数据的一些函数，在类中定义初始化的语句。

**管程的基本特征**：

1. 局部于管程的数据只能被局部于管程的过程所访问
2. 一个进程只有通过调用管程内的过程才能进入管程访问共享数据。(简单理解：**管程内定义的共享数据只能由管程内定义的函数所修改**)
3. **每次仅允许一个进程在管程内执行某个内部过程**(简单理解：**管程当中定义了很多函数，但是同一时刻肯定只有一个进程在使用管程当中的某一个函数**)
   - 比如我们把生产者消费者模型中的缓冲区定义为管程当中的某一种共享数据结构，缓冲区每次只能有一个进程进行访问，上述3就保证同一时刻只有一个进程在使用管城当中的某一个函数。

## 4.3、扩展1：用管程解决生产者消费者问题

![](王道OS第二章进程管理(二).assets/21.png)

上述代码是用了类C语言的伪代码来表示管程，管程的名字是 ProducerConsumer，我们可以在里面定义一些条件变量用来实现同步，还可以定义一些变量用来记录缓冲区中的产品数，生产者进程想向缓冲区放入一个自己新生产的产品，只需要直接调用管程当中的 insert 函数，不像之前我们的P、V操作，需要有一堆PV操作，但是现在采用了管程只需要很少的代码，生产者只需要生产一个产品，然后使用 insert 函数，至于同步互斥什么的均由管程进行管理。同样的，消费者进程也只需要调用 remove 函数，然后消费一个产品，之后缓冲区空了怎么办、缓冲区互斥访问等问题都不要管，全由管程进行解决。

- 我们定义了管程之后，**编译器**会负责实现各个进程互斥地进入管程中的过程，每次仅允许一个进程在管程内执行某个内部过程。所以程序员写代码，只需要调用管程提供的函数，就可以保证**进程是互斥的进行。**
  - 例如两个生产者进程并发执行，依次调用了 insert 函数，由于缓冲区内初始无产品，第一个生产者进程会顺利执行，而第二个生产者会被阻止进入 insert 函数。
- 除了互斥之外，管程还可以实现进程的同步，我们可以设置一些条件变量和等待/唤醒操作来实现同步问题。
  - 例如两个消费者进程先执行，第一个消费者进程调用 remove 函数，因为此时缓冲区为空，所以第一个消费者会被卡在 wait(empty) 进行等待，同样的第二个进程也要执行等待操作。只有生产者进程生产了产品之后才会将消费者进程唤醒。这样就实现了进程同步(保证一前一后)

---

==引入管程的目的无非就是想要更方便的实现进程互斥和同步==。

1. 需要在管程中定义共享数据(如生产者消费者问题的缓冲区)
2. 需要在管程中定义用于访问这些共享数据的"入口",其实就是一些函数(如生产者消费者问题中，可以定义一个insert函数用于将产品放入缓冲区，再定义一个remove函数用于从缓冲区取出产品)
3. 我们在生产者消费者进程当中是不可以直接访问缓冲区的，只有**通过这些特定的"入口"才能访问共享数据**
4. 管程中有很多"入口",**但是每次只能开放其中一个"入口"**，并且**只能让一个进程或线程进入**(如生产者消费者问题中，各进程需要互斥地访问共享缓冲区。管程的这种特性即可保证一个时间段内最多只会有一个进程在访问缓冲区。注意：**这种互斥特性是编译器负责实现的**，程序员不用关心)

5. 可在管程中设置**条件变量**及**等待/唤醒**操作以解决同步问题。可以让一个进程或线程在条件变量上等待(**此时，该进程应先释放管程的使用权，也就是让出"入口"**),可以通过唤醒操作将等待在条件变量上的进程或线程唤醒。



## 4.3、扩展2：java中类似于管程机制

Java中,如果用关键字 synchronized 来描述一个函数，那么这个函数就可以保证同一时间段内只能被一个线程调用。

```java
static class monitor{
    private Item buffer[] = new Item[N];
    private int count = 0;
    
    // 每次只能有一个线程进入 insert 函数,如果多个线程同时调用insert函数,则后来着需要排队等待
    public synchronized void insert(Item item){
        .....
    }
}
```





## 4.4、小结

![](王道OS第二章进程管理(二).assets/22.png)









# 5、死锁

![](王道OS第二章进程管理(二).assets/23.png)









## 5.1、什么是死锁

在并发环境下，各进程**因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进的现象，就是"死锁"**。发生死锁后若无外力干涉，这些进程都将无法向前推进。 

## 5.2、死锁、饥饿、死循环的区别

**死锁**：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。

**饥饿**：由于长期得不到想要的资源，某进程无法向前推进的现象。比如：在短进程优先(SPF)算法中，若有源源不断的短进程到来，则长进程将一直得不到处理机，从而发生长进程“饥饿”。

**死循环**：某进程执行过程中一直跳不出某个循环的现象。有时是因为程序逻辑bug 导致的，有时是程序员故意设计的。

|        | 共同点                                                   | 区别                                                         |
| ------ | -------------------------------------------------------- | ------------------------------------------------------------ |
| 死锁   |                                                          | 死锁一定是"循环等待对方手里的资源"导致的,因此如果有死锁现象,**那至少有两个或两个以上的进程同时发生死锁**。另外，发生死锁的进程一定处于阻塞态。 |
| 饥饿   | 都是进程无法顺利向前推进的现象<br>(故意设计的死循环除外) | **可能只有一个进程发生饥饿。**发生饥饿的进程既可能是阻塞态(如长期得不到需要的I/O设备)，也可能是就绪态(长期得不到处理机) |
| 死循环 |                                                          | 可能只有一个进程发生死循环，死循环的进程可以上处理机运行(可以是运行态)，只不过无法像期待的那样顺利推进。死锁和饥饿问题是由于操作系统分配资源的策略不合理导致的，而死循环是由代码逻辑的错误导致的。**死锁和饥饿是管理者(操作系统)的问题，死循环是被管理者的问题。** |

> - 死锁和饥饿肯定不可能是运行态，而死循环是可以是运行态的
> - 死循环一般是由程序员导致的

## 5.3、死锁产生的必要条件

产生死锁必须同时满足一下四个条件，只要其中任一条件不成立，死锁就不会发生。

- **互斥条件**：并发执行的进程只有对必须互斥使用的资源的争抢才会导致死锁（如哲学家的筷子、打印机设备）。像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的（因为进程不用阻塞等待这种资源）
- **不剥夺条件**：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。
- **请求和保持条件**：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。(每一个哲学家在保持一个资源不放的同时还在请求另一个新的资源，而那个新的资源又恰好被别的哲学家所持有，满足请求和保持的条件)
- **循环等待条件**：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。(每个哲学家都在等待右手边的哲学家放下筷子，这就形成了循环等待链)

> 注意：！发生死锁时一定有循环等待，但是发生循环等待时未必死锁（循环等待是死锁的必要不充分条件）
>
> - 比如突然来了第6个哲学家，他可以给3号哲学家右手边的筷子，这样3号哲学家既可以等4号哲学家的筷子，也可以等6号哲学家的筷子，虽然有循环等待链，但是没有死锁发生。
> - 循环等待 => 死锁

![](王道OS第二章进程管理(二).assets/24.png)

**如果同类资源数大于1，则即使有循环等待，也未必发生死锁。但如果系统中每类资源都只有一个，那循环等待就是死锁的充分必要条件了。**





## 5.4、什么时候会发生死锁

1. **对系统资源的竞争**。各进程对不可剥夺的资源（如打印机）的竞争可能引起死锁，对**可剥夺的资源**（CPU）的竞争是不会引起死锁的。
2. **进程推进顺序非法**。请求和释放资源的顺序不当，也同样会导致死锁。例如，并发执行的进程P1、P2 分别申请并占有了资源R1、R2，之后进程P1又紧接着申请资源R2，而进程P2又申请资源R1，两者会因为申请的资源被对方占有而阻塞，从而发生死锁。
3. **信号量的使用不当也会造成死锁**。如生产者-消费者问题中，如果实现互斥的P操作在实现同步的P操作之前，就有可能导致死锁。（可以把互斥信号量、同步信号量也看做是一种抽象的系统资源）

> 总之，对不可剥夺资源的不合理分配，可能导致死锁。

## 5.5、死锁的处理策略

1. **预防死锁。**破坏死锁产生的四个必要条件中的一个或几个。
2. **避免死锁。**用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法）
3. **死锁的检测和解除。**允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁。

## 4.6、小结

![](王道OS第二章进程管理(二).assets/25.png)



# 6、死锁的处理策略

## 6.1、预防死锁

![](王道OS第二章进程管理(二).assets/26.png)



### 6.1.1、破坏互斥条件

**互斥条件**：只有对必须互斥使用的资源的争抢才会导致死锁。

如果把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。比如：`SPOOLing技术`。操作系统可以采用 `SPOOLing` 技术把独占设备在逻辑上改造成共享设备。比如，用SPOOLing技术将打印机改造为共享设备。

![](王道OS第二章进程管理(二).assets/27.png)

在使用SPOOLing技术之前，若两个进程都想使用打印机这种资源，若进程1已经使用打印机资源，若进程2也想使用打印机资源，会进入阻塞态。在使用SPOOLing技术之后，各个进程对打印机资源发出的请求会首先被输出进程接收，当被接收之后这些进程就可以向下执行后面的代码了，之后输出进程会依次将请求放到打印机进行输出。

**该策略的缺点**：并不是所有的资源都可以改造成可共享使用的资源。并且为了系统安全，很多地方还必须保护这种互斥性。因此，**很多时候都无法破坏互斥条件。**

### 6.1.2、破坏不剥夺条件

**不剥夺条件**：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。

破坏不剥夺条件两个方案：

1. 当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时再重新申请。也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件。
2. 当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级（比如：剥夺调度方式，就是将处理机资源强行剥夺给优先级更高的进程使用）

该策略的**缺点**：

1. 实现起来比较复杂。
2. 释放已获得的资源可能造成前一阶段工作的失效。因此这种方法一般只适用于易保存和恢复状态的资源，如CPU。在CPU的资源被剥夺的时候，之前在CPU上运行的进程它的寄存器上保存的数据就需要被保存。
3. 反复地申请和释放资源会增加系统开销，降低系统吞吐量。
4. 若采用方案一，意味着只要暂时得不到某个资源，之前获得的那些资源就都需要放弃，以后再重新申请。如果一直发生这样的情况，就会导致进程饥饿。

### 6.1.3、破坏请求和保持条件

**请求和保持条件**：进程**已经保持了至少一个资源**，但又提出了新的资源**请求**，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源**保持不放**。

可以采用**静态分配方法**来破坏这个条件，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行。一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源了。

该策略实现起来简单，但也有明显的**缺点**：

- 有些资源可能只需要用很短的时间，因此如果进程的整个运行期间都一直保持着所有资源，就会造成严重的资源浪费，**资源利用率极低。**另外，该策略也有可能**导致某些进程饥饿。**
- 比如说一个系统中有资源1和资源2两种资源，有A、B、C三种进程，A类进程只需要使用资源1，B类进程只需要使用资源2，C类资源需要使用资源1和资源2才可以运行，如果系统中有源源不断的A、B类进程到达，那么C类进程会因为长时间等待而发生饥饿。

### 6.1.4、破坏循环等待条件

**循环等待条件**：存在一种进程**资源的循环等待链**，链中的每一个进程已获得的资源同时被下一个进程所请求。

**可采用顺序资源分配法**来破坏这个条件。首先给系统中的资源编号，规定每个进程**必须按编号递增的顺序请求资源**，同类资源（即编号相同的资源）一次申请完。

原理分析：一个进程只有已占有小编号的资源时，才有资格申请更大编号的资源。按此规则，已持有大编号资源的进程不可能逆向地回来申请小编号的资源，从而就不会产生循环等待链。在任何一个时刻，总有一个进程拥有的资源编号是最大的，那这个进程申请之后的资源必然畅通无阻。因此**不可能出现所有进程都阻塞的死锁现象。**


该策略的**缺点**：

1. 不方便增加新的设备，因为可能需要重新分配所有的编号
2. 进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源浪费
   - 例如1号进程需要使用5号资源打印机，也需要使用7号资源扫描仪，但是实际过程中是先使用扫描仪再使用打印机，但是由于编号递增申请的要求，1号进程必须先占有它暂时用不到的5号资源打印机，打印机会空闲一段时间，只有当1号进程占有7号资源扫描仪且使用之后，打印机才会投入工作。
3. 必须按规定次序申请资源，用户编程麻烦。





### 6.1.5、小结

![](王道OS第二章进程管理(二).assets/28.png)





## 6.2、避免死锁

![](王道OS第二章进程管理(二).assets/29.png)

### 6.2.1、安全序列

所谓**安全序列**，就是指如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要能找出一个安全序列，系统就是**安全状态**。当然，**安全序列可能有多个**。

如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了**不安全状态**。这就意味着之后**可能**所有进程都无法顺利的执行下去。当然，如果有进程提前归还了一些资源，**那系统也有可能重新回到安全状态**，不过我们在分配资源之前总是要考虑到最坏的情况。

- 如果系统处于**安全状态**，就**一定不会**发生**死锁**。

- 如果系统进入**不安全状态**，就**可能**发生**死锁**(处于不安全状态未必就是发生了死锁，但发生死锁时一定是在不安全状态)

因此可以**在资源分配之前预先判断这次分配是否会导致系统进入不安全状态**，以此决定是否答应资源分配请求。这也是"**银行家算法**"的核心思想。



 

### 6.2.2、银行家算法

核心思想：在进程提出资源申请时，先预判此次分配是否会导致系统进入不安全状态。如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待。

比如：系统中有5个进程P0~P4，3种资源R0 ~ R2，初始数量为(10,5,7),则某一时刻的情况可表示如下：

![image-20220510100226791](王道OS第二章进程管理(二).assets/30.png)

此时总共已分配(7,2,5),还剩余(3,3,2),可把最大需求、已分配的数据看作矩阵，两矩阵相减，就可算出各进程最多还需要多少资源了。

此时系统是否处于安全状态？思路：尝试找出一个安全序列：依次检查剩余可用资源(3,3,2)是否能满足各进程的需求，我们可以用(3,3,2)与各个进程的最多还需要资源数进行对比：

![](王道OS第二章进程管理(二).assets/31.png)

- 先和P0对比，发现(7,4,3)>(3,3,2),剩余可用资源满足不了P0的最大需要资源。

- 之后和P1对比，发现(1,2,2)<(3,3,2),剩余可用资源满足P1的最大需要资源。如果优先把资源分配给P1，那P1一定是可以顺利执行结束的，等P1结束了就会归还资源，于是，资源数就可以增加到(2,0,0)+(3,3,2)=(5,3,2),所以P1满足需求，将P1加入安全序列，并更新剩余可用资源值为(5,3,2)，依次检查剩余可用资源(5,3,2)是否能满足剩余进程(不包括已加入安全序列的进程)的需求：

![](王道OS第二章进程管理(二).assets/32.png)

- 可满足P3需求，将P3加入安全序列，并更新剩余可用资源值为(7,4,3),依次检查剩余可用资源。以此类推，共五次循环检查即可将5个进程都加入安全序列中，最终可得一个安全序列。该算法称为安全性算法。

---

实际做题时，手算可用更快速的方法找到一个安全序列：

![](王道OS第二章进程管理(二).assets/33.png)

经对比发现，(3,3,2)可满足P1、P3，说明无论如何，这两个进程的资源需求一定是可以依次被满足的，因此P1、P3一定可以顺利的执行完，并归还资源。可把P1、P3先加入安全序列。此时更新剩余可能资源数 (2,0,0)+(2,1,1)+(3,3,2)=(7,4,3)

![](王道OS第二章进程管理(二).assets/34.png)

剩下的P0、P2、P4都可被满足。同理，这些进程都可以加入安全序列。于是，5个进程全部加入安全序列，说明此时系统**处于安全状态**，暂**不可能发生死锁**。

![](王道OS第二章进程管理(二).assets/35.png)



#### 1、代码实现

- 假设**系统中有n个进程，m种资源**。每个进程在运行前先声明对各种资源的最大需求数，则可用一个 n*m 的矩阵(可用二维数组实现)表示所有进程对各种资源的最大需求数。不妨称为最大需求矩阵Max。

- 同理，系统可以用一个 n * m的**分配矩阵Allocation**表示对所有进程的资源分配情况。Max-Allocation = Need 矩阵，表示各进程最多还需要多少各类资源。
- 另外，还要用一个长度为m的一维数组 Available 表示当前系统种还有多少可用资源。
- 某进程Pi向系统申请资源，可用一个长度为m的一维数组 Request~i~ 表示本次申请的各种资源量。

![](王道OS第二章进程管理(二).assets/36.png)



可用银行家算法预判本次分配是否会导致系统进入不安全状态。

1. 如果Request~i~[j] ≤ Need[i,j] (0≤j≤m)便转向2，否则认为出错
   - 申请的资源量不超过它最多还需要的资源数，则认为申请合理
2. 如果Request~i~[j] ≤ Available[j] (0≤j≤m)便转向3，否则表示尚无足够资源，Pi必须等待
   - 此时系统当中剩余的资源数若满足它申请的数量，则跳到下一步
3. 系统试探着把资源分配给进程Pi，并修改相应的数据(并非真的分配，修改数值只是为了做预判)
   - Available = Available - Request~i~
   - Allocation[i,j] = Allocation[i,j] +Request~i~[j]
   - Need[i,j] = Need[i,j] -Request~i~[j]
4. 操作系统执行**安全性算法**，检查此次资源分配后，**系统是否处于安全状态**。若安全，才正式分配，否则，恢复相应数据，让进程阻塞等待。

---

**银行家算法步骤**：

1. 检查此次申请是否超过了之前声明的最大需求数
2. 检查此时系统剩余的可用资源是否还能满足这次请求
3. 试探着分配，更改各数据结构
4. 用安全性算法检查此次分配是否会导致系统进入不安全状态

安全性算法步骤：

检查当前的剩余可用资源是否能满足某个进程的最大需求，如果可以，就把该进程加入安全序列，并把该进程持有的资源全部回收。不断重复上述过程，看最终是否能让所有进程都加入安全序列。









## 6.3、死锁的检测和解除

![](王道OS第二章进程管理(二).assets/37.png)





### 6.3.1、死锁的检测

为了能对系统是否已发生了死锁进行检测，必须：

1. 用**某种数据结构**来保存资源的请求和分配信息
2. 提供**一种算法**，利用上述信息来检测系统是否已进入死锁状态

![](王道OS第二章进程管理(二).assets/38.png)

一般用数据结构资源分配图来表示资源的请求和分配信息，每个进程结点对应一个进程，每个资源结点对应一类资源。进程结点指向资源结点，表示进程想申请几个资源(一条边代表申请一个资源)，当资源结点指向进程结点，表示已经为进程分配了几个资源(一条边代表申请一个资源)，例如上图中，

- 进程结点是P1、P2，资源结点是R1、R2。

- R1资源有3个，R2资源有2个。
- P1指向R2，代表请求边，R1指向P1，代表分配边。上图中P1进程正在请求一个R2资源，P2进程正在请求一个R1资源。已经给P1分配了2个R1资源，给P2分配了1个R1资源。

如果系统中剩余的可用资源数足够满足进程的需求，那么这个进程暂时是不会阻塞的，可以顺利地执行下去。如果这个进程执行结束了把资源归还系统，就可能使某些正在等待资源的进程被激活，并顺利地执行下去。相应的，这些被激活的进程执行完了之后又会归还一些资源，这样可能又会激活另外一些阻塞的进程。

如果按上述过程分析，最终**能消除所有边**，就称这个图是**可完全简化的**。此时一定**没有发生死锁**(相当于能找到一个安全序列)，如果最终不能消除所有边，那么此时就是**发生了死锁**。**最终还连着边的那些进程就是处于死锁状态的进程。**

![](王道OS第二章进程管理(二).assets/39.png)

如上图，P1进程请求1个R2资源，而R2资源只被分配给P2一个，所以P1的请求可以被满足。P1进程不会被阻塞，但是P2进程此时请求1个R1资源，但是R1资源已经被分配给P1两个，P2一个，所以P2进程的请求不能被满足，P2进程会被阻塞。但是P1执行完之后就会将所有资源全部归还给系统，P1执行完我们将P1的所有边都消除掉，此时会激活P2进程，P2进程的请求可以被满足，则P2执行完后将所有的边都消除掉。

> 如果按上述过程分析，最终**能消除所有边**，就称这个图是**可完全简化的**。此时**一定没有发生死锁**（相当于能找到一个安全序列。如果最终**不能消除所有边**，那么此时就是**发生了死锁**

![](王道OS第二章进程管理(二).assets/41.png)

如上图，P1进程申请2个R2资源，R2已经将2个资源分别分配给P3和P2，所以P1进程会阻塞，P2进程申请1个R1找资源，R1已经将3个资源分别分配给P1和P2，P2进程也会被阻塞，此时可以顺利执行的只有P3进程，P3执行完会归还它占有的资源，P3的边全部消除掉，但是归还资源后R2的2个资源依然不满足P1的需求，所以P1仍会阻塞，P2也会阻塞。**这样就不能消除所有边，就发生了死锁。**

---

**检测死锁的算法**：

1. 在资源分配图中，找出既不阻塞又不是孤点的进程Pi(即找出一条有向边与它相连，且该有向边对应资源的申请数量小于等于系统中已有空闲资源数量)。如下图中，R1没有空闲资源，R2有一个空闲资源。若所有的连接该进程的边均满足上述条件，则这个进程能继续运行直至完成，然后释放它所占有的所有资源）。消去它所有的请求边和分配边，使之称为孤立的结点。在下图中，P1 是满足这一条件的进程结点，于是将P1的所有边消去。
   - 不阻塞的意思是说这个进程申请的资源足够满足它的需求。比如P1进程就是不阻塞的进程，P2进程就是阻塞的进程
   - 不是孤点指的是与这个进程至少有一个边相连，P1和P2都不是孤点
   - 满足既不阻塞又不是孤点的进程只有P1进程，则消去P1进程所有的请求边和分配边，使它称为孤点。
2. 进程Pi 所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可能变为非阻塞进程。在下图中，P1释放资源，P2 就满足既不阻塞也不是孤点。根据1中的方法进行一系列简化后，若能消去途中所有的边，则称该图是可完全简化的。

![](王道OS第二章进程管理(二).assets/40.png)



### 6.3.2、死锁的解除

一旦检测出死锁的发生，就应该立即解除死锁。并不是系统中所有的进程都是死锁状态，**用死锁检测算法化简资源分配图后，还连着边的那些进程就是死锁进程**。比如上上图中的P3就不是死锁状态，只有P1、P2是死锁状态。

解除死锁的主要方法有：

1. **资源剥夺法**：挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。
2. **撤销进程法（或称终止进程法）**：强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，已经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来
3. **进程回退法**：让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程的历史信息，设置还原点。

我们如何决定让哪个进程进行牺牲呢？

1. 进程优先级。进程优先级低的我们可以对它下手，使用上述方法来解除死锁。
2. 已执行多长时间。执行时间短的可以牺牲。
3. 还要多久能完成。需要时间长的可以牺牲。
4. 进程已经使用了多少资源。使用资源少的可以牺牲。
5. 进程是交互式还是批处理式的。优先牺牲批处理式的，交互式若被干掉用户就不爽了😅





### 6.3.3、小结

![](王道OS第二章进程管理(二).assets/42.png)

























 
