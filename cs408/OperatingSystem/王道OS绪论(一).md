# 1、操作系统

![](王道OS绪论(一).assets/41.png)

## 1.1、操作系统的概念和定义

**操作系统**(Operating System)是指控制和管理整个计算机系统的**硬件和软件**资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境，它是计算机系统中最基本的系统软件。



![](王道OS绪论(一).assets/1.png)



- **操作系统是系统资源的管理者**：操作系统作为软件和硬件之间的桥梁，是系统资源的管理者，既管理了软件资源，也管理了硬件资源。
- **操作系统向上层提供方便易用的服务**：操作系统向用户、应用程序提供服务
- **操作系统是最接近硬件的一层软件**



## 1.2、操作系统的功能和目标

### 1.2.1、操作系统是系统资源的管理者

- 我们在执行一个程序之前**需要将该程序放到内存中**，才能被CPU处理。

例如我们用QQ和朋友视频聊天：

1. 在文件夹中找到QQ安装的位置 -> ==找到QQ.exe可执行文件的存放位置==

2. 双击打开 `QQ.exe` -> ==需要把该程序相关数据放入内存==
3. QQ程序运行 -> ==对应的进程被处理机(CPU)处理==
4. 开始和朋友聊天 -> ==需要将摄像头设备分配给进程==

### 1.2.2、操作系统向上层提供方便易用的服务

![](王道OS绪论(一).assets/2.png)

1. 用户告诉操作系统需要什么服务
2. 操作系统会把用户的需求翻译为二进制来告诉硬件
3. 硬件来执行操作



#### 1、联机命令接口

**联机命令接口**也称为**交互式命令接口**

1. 在Windows系统中输入 `win+r`
2. 输入`cmd`，打开命令解释器
3. 使用 `time`命令

- 联机命令接口的特点：==用户说一句，系统跟着做一句==



#### 2、脱机命令接口

**脱机命令接口**也称为**批处理命令接口**

1. 例如我们平常会玩的一些 `.bat`后缀的文件
2. 其实本质和联机命令接口是相同的，只是将很多联机命令接口写在了 `.bat`文件中

- 脱机命令接口的特点：==用户说一堆，系统跟着做一堆==

#### 3、程序接口

程序接口是给程序员使用的，可以在程序中进行**系统调用**来使用程序接口。普通用户不能直接使用程序接口

1. 例如我们写C语言的`Hello World!`时,在`printf`函数的底层就使用到了操作系统提供的显示相关的 **系统调用**
2. 程序员写代码 -> 调用C语言库函数 -> 操作系统提供显示相关的系统调用 ->显示在显示器上

- 有的教材也将**系统调用**称为==广义指令==



![](王道OS绪论(一).assets/6.png)



- 有的教材会把**命令接口和程序接口统称为用户接口**，不包含GUI
- 联机命令接口和脱机命令接口的区别在于用户说一句做一句还是说一堆做一堆。
  - 联机命令接口：交互式命令接口，用户说一句系统做一句
  - 脱机命令接口：批处理命令接口，用户说一堆系统做一堆



### 1.2.3、操作系统是最接近硬件的一层软件

操作系统可以**实现对硬件机器的扩展**，没有任何软件支持的计算机称为**裸机**。在裸机上安装的操作系统，可以提供资源管理功能和方便用户的服务功能，将裸机改造成功能更强、使用更方便的机器。通常把覆盖了软件的机器称为**扩充机器**，也称为**虚拟机**。

操作系统对硬件机器的扩展：将CPU、内存、磁盘、显示器、键盘等硬件合理地组织起来，让各种硬件能够相互协调配合，实现更多更复杂的功能。





# 2、操作系统的特征

![](王道OS绪论(一).assets/3.png)

## 2.1、并发

**并发**：指两个或者多个事件在同一时间间隔内发生。这些事件**宏观上是同时发生的**，但**微观上是交替发生**的。

**并行[常考易混概念]**：指两个或多个事件在同一时刻同时发生。

**操作系统的并发性**：指的是计算机系统中"同时"运行着多个程序，这些程序宏观上看是同时运行着的，而围观上看是交替运行的。操作系统就是伴随着"多道程序技术"而出现的，因此，**操作系统和程序并发是一起诞生的。**

> 注意：(重要考点)
>
> - `单核CPU`同一时刻只能执行`一个程序`，多个程序只能`并发`地执行。
>
> - `多核CPU`同一时刻可以同时执行`多个程序`，多个程序可以`并行`地执行。

比如 Intel 的第八代 i3 处理器就是4核CPU，意味着可以并行地执行4个程序。即使对于4核CPU来说，只要有4个以上的程序需要"同时"运行，那么并发性依然是必不可少的，因此"**并发性**"是操作系统一个最基本的特性。





## 2.2、共享

**共享**：即资源共享，是指系统中的资源可供内存中多个**并发**执行的进程同时使用。

**两种资源共享方式**：

- **互斥共享方式**：系统中的某些资源，虽然可以提供给多个进程使用，但**一个时间段内只允许一个进程访问该资源**
- **同时共享方式**：系统中的某些资源，**允许一个时间段内由多个进程"同时"对它们进行访问**。

所谓"同时"往往是宏观的，而在微观上，这些进程可能是交替地对该资源进行访问的(即分时共享)

---

==生活实例==：

- **互斥共享方式**：使用QQ和微信视频。同一时间段内摄像头只能分配给其中一个进程。

- **同时共享方式**：使用QQ发送文件A，同时使用微信发送文件B。宏观上看，两边都在同时读取并发送文件，说明两个进程都在访问硬盘资源，从中读取数据。微观上看，两个进程是交替着访问硬盘的。



### 2.2.1、并发和共享的关系

- **并发性**指计算机系统中同时存在着多个运行着的程序。
- **共享性**是指系统中的资源可供内存中多个并发执行的进程共同使用。

![](王道OS绪论(一).assets/7.png)

> 如果失去了并发性，共享性就失去了存在的意义，而如果失去了共享性，并发性就不可能被实现。**并发性和共享性互为存在条件。**

## 2.3、虚拟

**虚拟**：把一个物理上的实体变为若干个逻辑上的对应物。物理实体(前者)是实际存在的，而逻辑上对应物(后者)是用户感受到的。

![](王道OS绪论(一).assets/8.png)



![](王道OS绪论(一).assets/9.png)

---

虚拟技术分为：

- **空分复用技术(如虚拟存储器技术)**
- **时分复用技术(如虚拟处理器)**

显然，如果失去了并发性，则一个时间段内系统中只需运行一道程序，那么就失去了实现虚拟性的意义了。**因此，没有并发性，就谈不上虚拟性。**

## 2.4、异步

**异步**是指，在多道程序环境下，允许多个程序**并发**执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性

- 由于并发运行的程序会争抢着使用系统资源，而系统中的资源有限，因此进程的执行不是一贯到底的，而是走走停停的，以不可预知的速度向前推进。这其实就是摄像头只有一个，我们在QQ和微信和别人打视频，一会用微信打，一会用QQ打，两个程序争抢使用摄像头资源。
- 如果失去了并发性，即系统只能串行地运行各个程序，那么每个程序的执行会一贯到底。**只有系统拥有并发性，才有可能导致异步性**





## 2.5、小结

![](王道OS绪论(一).assets/10.png)





# 3、操作系统的发展与分类

![](王道OS绪论(一).assets/11.png)



## 3.1、手工操作阶段

![](王道OS绪论(一).assets/12.png)

**手工操作阶段**：程序员把写自己好的程序放到纸袋机，计算机从纸袋机读取程序运行，最后将结果输出到纸袋机上，程序员再从纸袋机拿结果。这样第二个程序员重复上一个程序员的操作。

**缺点**：

1. 用户独占全机
2. 人机速度矛盾导致资源利用率极低。(人慢，机器运算快)



## 3.2、批处理阶段

### 3.2.1、单道批处理系统

**单道批处理系统**：引入**脱机输入/输出技术**，并由**监督程序**负责控制作业的输入、输出。

![](王道OS绪论(一).assets/13.png)

各个程序员可以把自己写好的程序同时放入纸袋机，由外围机把程序提前存到磁带里，之后计算机直接从磁带读取程序，此时的计算机中会运行监督程序，由这个监督程序负责控制作业的输入和输出。

**主要优点**：缓解了一定程度的人机速度矛盾，资源利用率有所提升。

**主要缺点**：**内存中仅能有一道程序运行**，只有该程序运行结束之后才能调用下一道程序。**CPU有大量的时间是在空闲等待I/O完成。资源利用率仍然很低**。







### 3.2.2、多道批处理系统

![](王道OS绪论(一).assets/14.png)

**多道批处理系统**：操作系统正式诞生，用于支持多道程序**并发**运行，监督程序每次往内存中读入多道程序，然后让这些程序并发的运行。



**主要优点**：多道程序**并发**执行，**共享**计算机资源。**资源利用率大幅提升**，CPU和其他资源更能保持忙碌状态，系统吞吐量增大。

**主要缺点**：：**用户响应时间长，没有人机交互功能**（用户提交自己的作业之后就只能等待计算机处理完成，中间不能控制自己的作业执行。eg：(无法调试程序/无法在程序运行过程中输入一些参数）





## 3.3、分时操作系统

**分时操作系统**：计算机以**时间片**为单位**轮流为各个用户/作业服务**，各个用户可通过终端(键盘、鼠标等)与计算机进行交互。比如下图，先给第一个用户服务50ms，再给第二个用户服务50ms

![](王道OS绪论(一).assets/15.png)



**主要优点**：用户请求可以被即时响应，**解决了人机交互问题**。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。

**主要缺点**：**不能优先处理一些紧急任务**。操作系统对各个用户/作业都是完全公平的，循环地为每个用户/作业服务一个时间片，不区分任务的紧急性。





## 3.4、实时操作系统

**主要优点**：能够优先响应一些紧急任务，某些紧急任务不需**时间片排队**。

在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且要在严格的时限内处理完事件。实时操作系统的主要特点是**及时性和可靠性**。



![](王道OS绪论(一).assets/16.png)

## 3.5、小结

![](王道OS绪论(一).assets/4.png)





# 4、操作系统的运行机制

![](王道OS绪论(一).assets/17.png)

## 4.1、预备知识



![](王道OS绪论(一).assets/18.png)

- 指令：指令就是CPU能识别、执行的最基本的命令，本节中的指令是指的是 **二进制的机器指令**





## 4.2、内核程序和应用程序

- 我们普通程序员写的程序就是"**应用程序**"，应用程序就是跑在操作系统之上的，比如QQ、微信等。
- 微软、苹果有一帮人负责实现操作系统，他们写的是"**内核程序**"，由很多内核程序组成了"操作系统内核"，或简称"内核(Kernel)",**内核是操作系统中最重要最核心的部分**，也是最接近硬件的部分。甚至可以说，一个操作系统只要有内核就够了(eg:Docker => 仅需Linux内核)，操作系统的功能未必都在内核中，如图形化用户界面GUI。我们平常使用的操作系统包含的其实不止是内核的功能，比如图形化用户界面就不是在内核中实现的，即使没有图形化界面，我们也可以使用`cmd`命令解释器来使用操作系统。
- **总结：操作系统的内核里面是最核心、最重要的功能。**

### 4.1.2、特权指令和非特权指令

![](王道OS绪论(一).assets/19.png)



**内核程序的指令**我们称为**特权指令**，**应用程序的指令**我们称为**非特权指令**，CPU能在执行一条指令前就判断出其类型。

### 4.1.3、内核态和用户态

CPU能判断出指令类型，但是它怎么区分此时正在运行的是内核程序还是应用程序呢？

![](王道OS绪论(一).assets/20.png)

CPU有两种状态：**内核态和用户态**

- 当CPU处于**内核态**时，说明此时**正在运行的是内核程序**，此时**可以执行特权指令**
- 当CPU处于**用户态**时，说明此时**正在运行的是应用程序**，此时**只能执行非特权指令**

如何区分CPU此时处于哪种状态呢？

- 在CPU中有一个寄存器叫 **程序状态字寄存器(PSW)**，其中有个二进制位，1表示内核态，0表示用户态。
- **别名**： 内核态=核心态=**管态**，用户态=**目态**

如何实现内核态和用户态的切换呢？

- **内核态 -> 用户态**：执行一条**特权指令--修改PSW**的标志位为"用户态"，这个动作意味着操作系统将主动让出CPU使用权
- **用户态 -> 内核态**：由"**中断**"引发，**硬件自动完成变态过程**，触发中断信号意味着操作系统将强行夺回CPU的使用权。

![](王道OS绪论(一).assets/21.png)



## 4.2、小结

![](王道OS绪论(一).assets/22.png)





# 5、中断和异常



![](王道OS绪论(一).assets/23.png)





## 5.1、中断的作用

CPU上会运行两种程序，一种是==操作系统内核程序(整个系统的管理者)==，一种是==应用程序==

- 在合适的情况下，操作系统内核会把CPU的使用权主动让给应用程序
- **中断**会使CPU由用户态转变为内核态，使操作系统重新夺回对CPU的控制权

如果没有“中断”机制，那么一旦应用程序上CPU运行，CPU就会一直运行这个应用程序。既如此，何来并发呢？



## 5.2、中断的类型

![](王道OS绪论(一).assets/24.png)



### 5.2.1、内中断

**内中断**：与当前执行的指令有关，中断信号来源于CPU内部。(若当前执行的指令是非法的，则会引发一个中断信号)

例子：

1. 试图在用户态下执行特权指令
   - 当应用程序在执行非特权指令的时候，黑客在里面插入了一条特权指令，CPU识别到特权指令产生中断信号，并会切换为内核态。**这个中断是由执行的指令引起的，称为内中断**。
2. 执行除法指令时发现除数为0
   - 有时候在用户态下执行非特权指令也会引发内中断，例如执行除法指令发现除数为0，这样也会引发内中断
3. 有时候应用程序想请求操作系统内核的服务，此时会执行一条**特殊的指令——陷入指令[非特权指令]**，该指令会引发一个内部中断信号。(执行陷入指令，意味着应用程序主动地将CPU控制权还给操作系统内核。"系统调用"就是通过陷入指令来完成的)



### 5.2.2、外中断

外中断：与当前执行的指令**无关**，中断信号来源于**CPU外部**。(**每一条指令结束后**，CPU都会例行检查是否有外中断信号)

例子：

1. **时钟中断**：由时钟部件发来的中断信号(时钟部件每隔一个时间片(如50ms)会给CPU发送一个时钟中断信号)
   - 通过这个时钟中断信号就可以实现多道程序并发运行。例如两个应用程序想要并发运行，首先应用程序1运行在用户态，当过了50ms之后时钟部件会给CPU发送一个中断信号(**这个中断信号是由CPU外部发出的，所以称为外中断**)，当CPU收到中断信号时会先暂停此时正在运行的应用程序，转而执行相应的内核程序来处理中断信号，之后由内核程序控制接下来让应用程序2上CPU运行，所以切换为用户态让应用程序2上CPU运行。
2. I/O中断：由输入/输出设备发来的中断信号(当输入输出任务完成时，向CPU发送中断信号)
   - 例如打印机打印任务完成之后，会向CPU发送中断信号

![](王道OS绪论(一).assets/42.png)





## 5.3、中断机制的基本原理

- ==不同的中断信号，需要用不同的中断处理程序来处理==
- 当CPU检测到中断信号后，会根据中断信号的类型去查询“中断向量表”，以此来找到相应的中断处理程序在内存中的存放位置。

- 显然，**中断处理程序一定是内核程序**，需要运行在"**内核态**"。



![](王道OS绪论(一).assets/26.png)





## 5.5、小结

![](王道OS绪论(一).assets/27.png)



# 6、系统调用

![](王道OS绪论(一).assets/28.png)





## 6.1、什么是系统调用

知识点回顾：操作系统作为用户和计算机硬件之间的接口，需要向上提供一些简单易用的服务。主要包括命令接口和程序接口。其中，程序接口由一组**系统调用**组成。

![](王道OS绪论(一).assets/29.png)



- "系统调用"是操作系统提供给应用程序（程序员/编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，==应用程序可以通过系统调用来请求获得操作系统内核的服务==



## 6.2、系统调用与库函数的区别

|              |                                                              |
| ------------ | ------------------------------------------------------------ |
| 普通应用程序 | 可直接进行系统调用，也可使用库函数。有的库函数涉及系统调用，有的不涉及 |
| 编程语言     | 向上提供库函数。有时会将系统调用封装成库函数，以隐藏系统调用的一些细节，使程序员编程更加方便。 |
| 操作系统     | 向上提供系统调用，使得上层程序能请求内核的服务。             |
| 裸机         |                                                              |

其实我们在写代码的时候是可以直接写汇编语言来请求系统调用的服务，但是由于高级语言的出现，我们一般都是通过调用C库函数、Python库函数等，这些库函数在底层其实也是调用了操作系统提供的系统调用来请求操作系统的服务。 **所以系统调用是比高级语言库函数更为底层的接口。**

我们的裸机之上是操作系统，**操作系统向上提供的接口是系统调用**，使得上层程序通过调用这些接口来请求内核的服务，操作系统之上各种各样的高级编程语言会用库函数的方式来封装这些系统调用，然后向更上层编写应用程序的程序员暴漏更好用的接口。但**并不是所有的库函数都会使用系统调用**：

- 不涉及系统调用的库函数：如"取绝对值"的函数。
- 涉及系统调用的库函数：如"创建一个新文件"的函数。



## 6.3、为什么系统调用是必须的

![](王道OS绪论(一).assets/30.png)





## 6.4、什么功能要用到系统调用

应用程序通过**系统调用**请求操作系统的服务。而系统中的各种共享资源都由操作系统内核统一掌管，因此**凡是与共享资源有关的操作(如存储分配、I/O操作、文件管理等)，都必须通过系统调用的方式向操作系统内核提出服务请求**，由操作系统内核代为完成。这样可以保证**系统的稳定性和安全性**，防止用户进行非法操作。

![](王道OS绪论(一).assets/31.png)





## 6.5、系统调用的过程

一个应用程序运行在用户态，当它想要发出系统调用的时候，它需要用**传参数的指令**给CPU的寄存器当中传递一些必要的参数，操作系统会根据这些参数来判断它到底需要哪种类型的服务，当传参指令都放到CPU的寄存器之后，应用程序就会执行 **陷入指令**来发出**内中断信号**，CPU就会切换为**内核态**，来执行相应的系统调用指令。

![](王道OS绪论(一).assets/32.png)

**注意**：

- **陷入指令**是在**用户态**执行的，执行陷入指令之后立即引发一个**内中断**，使CPU进入**核心态**
- **发出系统调用请求**是在**用户态**，而**对系统调用的相应处理**在**核心态**下进行

- 别名：陷入指令 = trap指令 = 访管指令





## 6.6、小结

![](王道OS绪论(一).assets/33.png)









# 7、操作系统的体系结构



![](王道OS绪论(一).assets/34.png)





## 7.1、操作系统的内核

操作系统还可以细分为如下图：

![](王道OS绪论(一).assets/35.png)

**内核**是操作系统最基本、最核心的部分。实现操作系统内核功能的那些程序就是**内核程序**。

![](王道OS绪论(一).assets/36.png)



有些操作系统只会在内核中放**与硬件关联较紧密的模块**，所以这就引出了两种内核截然不同的设计方法，分别为大内核和微内核。

## 7.2、大内核和微内核

**大内核**：把所有功能都包含在操作系统内核当中称为大内核。

**微内核**：只保留与与硬件关联较紧密的模块称为微内核。如果采用微内核的设计方法，属于内核的功能是需要运行在内核态的，不属于内核的上面的功能就需要运行在用户态。

![](王道OS绪论(一).assets/37.png)

注意：

- 操作系统**内核**需要运行在**内核态**
- 操作系统的**非内核**功能运行在**用户态**



![](王道OS绪论(一).assets/38.png)



如上图，两种设计方法下的操作系统：如果一个应用程序想要请求操作系统的服务，这个服务同时涉及到进程管理、存储管理、设备管理

- 对于大内核的设计方式，应用程序向操作系统提出请求，这个时候CPU会从用户态切换为内核态
- 对于微内核的设计方式，应用程序向操作系统提出请求，再分别请求这几个服务的时候，这几个服务分别需要内核的支持，所以CPU从用户态转到内核态，服务完成后又从内核态转回用户态。





## 7.3、小结

![](王道OS绪论(一).assets/39.png)





# 8、第一章知识回顾

![](王道OS绪论(一).assets/40.png)









# 9、操作系统引导(Boot)

操作系统引导：开机的时候怎么让操作系统运行起来？

![](王道OS绪论(一).assets/43.png)

当我们买了一个机械硬盘后，它是空的。操作系统安装在C盘，除了我们能看得见的磁盘分区之外，在磁盘的开头部分会留出一些区域，这片区域用于存储主引导记录，包含磁盘引导程序和分区表，这个分区表其实就是一个数据结构，它说明了哪个盘在哪个位置占多大空间，C盘安装了操作系统，我们称C盘是这个磁盘的**活动分区**，我们再把C盘内部进一步细分如下图：

![](王道OS绪论(一).assets/44.png)

C盘有一片区域用来引导记录PBR，其次还有根目录(就是你双击打开C盘后看到的目录)。计算机的主存由ROM和RAM组成， ROM里面有BIOS(Basic input/output System)，包含ROM引导程序，即自举程序。

 RAM里面的数据只要断电就被清空，但ROM里面的程序是不会因为断电就清空的。所以电脑开机之后，CPU就可以去主存里面找到这个ROM引导程序，然后执行这个程序里面的指令，指令会让CPU找到主引导记录并将其读入内存，接着CPU就可以用来执行磁盘引导程序，磁盘引导程序会根据分区表来确定C盘所处的位置，这样就可以找到C盘的第一部分引导记录PBR，执行这个程序会找到启动管理器，完成开机的一系列动作。



操作系统引导：

1.  CPU从一个特定主存地址开始，取指令，执行ROM中的引导程序(先进行硬件自检，再开机)
2. 将磁盘的第一块——主引导记录读入内存，执行磁盘引导程序，扫描分区表
3. 从活动分区(又称为主分区，即安装了操作系统的分区)读入分区引导记录执行其中的程序
4. 从根目录下找到完整的操作系统初始化程序(即启动管理器)并执行，完成开机的一系列动作

例如：Windows电脑在C盘的Windows/boot目录下的一系列目录就是操作系统初始化程序(即启动管理器)





# 10、虚拟机

虚拟机：使用虚拟化技术，将一台物理机器虚拟化为多台虚拟机器，每个虚拟机器都可以独立运行一个操作系统。将一台虚拟机(物理机器)虚拟化为多台虚拟机器，需要用到**虚拟机管理程序**(VMM)/**虚拟机监控程序**

![](王道OS绪论(一).assets/45.png)

虚拟机管理程序分为两类：

- 第一类虚拟机管理程序直接**运行在硬件之上**，将一台物理机器虚拟化为多台虚拟机器。会把一个总的硬件资源分配给各个虚拟机器使用，每一台虚拟机器上面可以安装各自的操作系统，如上图第1台虚拟机器安装windows，第2台安装Linux，第3台又安装windows，在每个操作系统之上又可以运行各自的用户进程。
  - 只有**虚拟机管理程序**是运行在**内核态**的，可以使用特权最高的指令，而上层的多台虚拟机器的操作系统，其实是运行在用户态的，但是上层的操作系统并不知道自己运行在用户态，所以上层的操作系统依然会使用特权指令，当他发出想使用特权指令的时候，会被第一类虚拟机管理程序截获并进行等价的转换，给上层的操作系统模拟出指令执行成功的感觉。
  - 所以上层的操作系统其实是运行在**虚拟内核空间**的
- 第二类虚拟机管理程序是运行在**宿主操作系统**上，例如在windows（**宿主操作系统**）电脑上安装Linux（**客户操作系统**）虚拟机。



## 10.1、两类虚拟机管理程序VMM的对比

|                    | 第一类VMM                                                    | 第二类VMM                                                    |
| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 对物理资源的控制权 | 直接运行在硬件之上，能直接控制和分配物理资源                 | 运行在宿主操作系统之上，依赖于宿主操作系统为其分配物理资源   |
| 资源分配方式       | 在安装客户操作系统的时候，第一类VMM会在原本的硬盘上给它分配存储空间，类似于"外核"的分配方式 | 客户操作系统拥有自己的虚拟磁盘，这个盘实际上是宿主操作系统中的一个大文件，客户操作系统分配到的内存是虚拟内存 |
| 性能               | 性能更好                                                     | 性能更差，总是需要宿主操作系统作为"中介"                     |
| 可支持的虚拟机数量 | 更多，不需要和宿主操作系统竞争资源，相同的硬件资源可以支持更多的虚拟机 | 更少，宿主操作系统本身需要使用物理资源，宿主操作系统上运行的其他进程也需要物理资源 |
| 虚拟机的可迁移性   | 更差                                                         | 更好，只需导出虚拟机镜像文件即可迁移到另一台宿主操作系统上，商业化应用更广泛 |
| 运行模式           | 第1类虚拟机管理程序运行在最高特权级(Ring 0 )，可以执行最高特权的指令 | 第2类虚拟机管理技术部分运行在用户态，部分运行在内核态。客户操作系统发出的系统调用会被第2类虚拟机管理系统截获并转化为第2类虚拟机管理程序对宿主操作系统的系统调用 |



## 10.2、支持虚拟化的CPU通常分更多指令等级

![](王道OS绪论(一).assets/46.png)

越往上指令权限越低，越往下指令权限越高





















