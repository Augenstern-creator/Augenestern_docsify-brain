# 💪

## 1、简单说下你对并发和并行的理解

1. 并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生
2. 并行是在不同实体上的多个事件，并发是在同一实体上的多个事件



## 2、同步、异步、阻塞、非阻塞的概念

**同步**：当一个同步调用发出后，调用者要一直等待返回结果。通知后，才能进行后续的执行

**异步**：当一个异步过程调用发出后，调用者不能立刻得到返回结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者

**阻塞**：是指调用结果返回前，当前线程会被挂起，即阻塞

**非阻塞**：是指即使调用结果没返回，也不会阻塞当前线程



## 3、进程和线程的基本概念

进程：进程是系统进行资源分配和调度的一个基本单位，是系统中的并发执行的单位

线程：线程是进程的一个实体，也是 CPU 调度和分派的基本单位，它是比进程更小的能独立运行的基本单位

- 进程是资源分配的最小单位，而线程是 CPU 调度的最小单位
- 创建进程或撤销进程，系统都要为之分配或回收资源，操作系统开销远大于创建或撤销线程时的开销
- 不同进程地址空间相互独立，同一进程内的线程共享同一地址空间。一个进程的线程在另一个进程内是不可见的
- 进程间不会相互影响，而一个线程挂掉将可能导致整个进程挂掉

> 为什么有了进程，还要有线程呢？

进程可以使多个程序并发执行，以提高资源的利用率和系统的吞吐量，但是其带来了一些缺点

1. 进程在同一时间只能干一件事情
2. 进程在执行的过程中如果阻塞，整个进程就会被挂起，即使进程中有些工作不依赖与等待的资源，仍然不会执行

基于以上的缺点，操作系统引入了比进程粒度更小的线程，作为并发执行的基本单位，从而减少程序在并发执行时所付出的时间和空间开销，提高并发性能。





## 4、进程五状态模型

![](操作系统(一).assets/1.png)

1. 进程运行之前需要被创建，在创建的过程中系统会完成一系列相应的工作，包括新建PCB、给进程分配一系列资源等，如果一个进程正在被创建的话，那么这个进程当前处于 **创建态**
2. 当进程被创建完成就有了上CPU的条件，这个时候进程就处于 **就绪态**，也就是说处于就绪态的进程只差**处理机**这种资源，其他资源全部具备
3. 处于**就绪态**的进程被操作系统调度这个进程就可以上处理机运行，当它在处理机上运行的时候它就处于 **运行态**，也就是说正在处理机上运行的进程既有其他全部资源也有了处理机这种资源
4. 有时正在运行的进程可能会等待某种事件的发生，在这个事件发生之前这个进程是没有办法继续向下执行，所以这个进程此时会**被剥夺处理机资源以及其他全部资源**，这个时候进程就处于 **阻塞态**
   - 运行态执行P操作**申请资源**，可能由于资源不够而进入阻塞态
   - P操作只有在进程执行的过程中执行，所以P操作只会从 运行态 -> 阻塞态，不会从 阻塞态 -> 就绪态
5. 若进程等待的事件发生了，那么这个进程就可以从 **阻塞态** 回到 **就绪态**
6. 处于 **运行态**的进程可以主动请求运行结束，或者运行过程中遇到不可修复的错误时，会从 **运行态**转变为 **终止态**

- 运行态->阻塞态 是一种进程自身做出的==主动行为==
- 阻塞态->就绪态 不是进程自身能控制的，是一种==被动行为==，**需要其他相关进程的协助**

**注意**：有的时候进程可以直接从**运行态**转换为 **就绪态**，比如说操作系统给进程分配的时间片用完了、或者处理机被更重要的进程抢占了的时候。所以**等待时间片的进程处于就绪态，等待CPU调度的进程处于就绪态**。





## 5、进程间的通信方式有哪些

进程间通信（IPC，InterProcess Communication）是指在不同进程之间传播或交换信息。IPC 的方式通常有管道（包括无名管道和命名管道）、消息队列、信号量、共享存储、Socket、Streams 等。其中 Socket 和 Streams 支持不同主机上的两个进程 IPC。

**管道**：

1. 它是半双工的，具有固定的读端和写端
2. 它只能用于父子进程或者兄弟进程之间的进程的通信
3. 它可以看成是一种特殊的文件，对于它的读写也可以使用普通的 read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中

**命名管道**：

1. FIFO可以在无关的进程之间交换数据，与无名管道不同
2. FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中

**消息队列**：

1. 消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符 ID 来标识
2. 消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级
3. 消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除
4. 消息队列可以实现消息的随机查询，消息不一定要以先进先出的次序读取，也可以按消息的类型读取

**信号量**：

1. 信号量（semaphore）是一个计数器。用于实现进程间的互斥与同步，而不是用于存储进程间通信数据
2. 信号量用于进程间同步，若要在进程间传递数据需要结合共享内存
3. 信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作
4. 每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数
5. 支持信号量组

**共享内存**：

1. 共享内存（Shared Memory），指两个或多个进程共享一个给定的存储区
2. 共享内存是最快的一种 IPC，因为进程是直接对内存进行存取





## 6、进程的调度算法有哪些

调度算法是指：根据系统的资源分配策略所规定的资源分配算法。

常用的调度算法有：先来先服务调度算法、时间片轮转调度法、短作业优先调度算法、最短剩余时间优先、高响应比优先调度算法、优先级调度算法等等



## 7、什么是死锁

死锁，是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。 例如：如果此时有一个线程 A，已经持有了锁 A，但是试图获取锁 B，线程 B 持有锁 B，而试图获取锁 A，这种情况下就会产生死锁



## 8、产生死锁的原因

由于系统中存在一些不可剥夺资源，而当两个或两个以上进程占有自身资源，并请求对方资源时，会导致每个进程都无法向前推进，这就是死锁。

- **竞争资源**：系统中只有一台打印机，可供进程 A 使用，假定 A 已占用了打印机，若 B 继续要求打印机打印将被阻塞。
  - 可剥夺资源：是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺，CPU 和主存均属于可剥夺性资源
  - 不可剥夺资源，当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放，如磁带机、打印机等

- **进程推进顺序不当**：进程 A 和 进程 B 互相等待对方的数据

  

## 9、死锁产生的必要条件

1. 互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用
2. 请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放
3. 不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放
4. 循环等待条件：在发生死锁时，必然存在一个进程–资源的环形链

## 10、解决死锁的基本方法

1. 预防死锁
   - 破坏请求条件：一次性分配所有资源，这样就不会再有请求了
   - 破坏请保持条件：只要有一个资源得不到分配，也不给这个进程分配其他的资源
   - 破坏不可剥夺条件：当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源
   - 破坏循环等待条件：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反
2. 避免死锁：银行家算法
3. 解除死锁
   - 资源剥夺：挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他死锁进程
   - 撤销进程：强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源
   - 进程回退：让一个或多个进程回退到足以避免死锁的地步。进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。







## 11、什么是缓冲区溢出，有什么危害

缓冲区为暂时置放输出或输入资料的内存。

缓冲区溢出是指当计算机向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法数据上。

造成缓冲区溢出的主要原因是程序中没有仔细检查用户输入是否合理。计算机中，缓冲区溢出会造成的危害主要有以下两点：程序崩溃导致拒绝服务和跳转并且执行一段恶意代码



## 12、分页和分段的区别

1. 段是信息的逻辑单位，它是根据用户的需要划分的，因此段对用户是可见的；页是信息的物理单位，是为了管理主存的方便而划分的，对用户是透明的
2. 段的大小不固定，由它所完成的功能决定；页的大小固定，由系统决定
3. 段向用户提供二维地址空间；页向用户提供的是一维地址空间
4. 段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制



## 13、物理地址、逻辑地址、虚拟内存的概念

- 物理地址：它是**地址转换的最终地址**，进程在运行时执行指令和访问数据最后都要通过物理地址从主存中存取，是内存单元真正的地址
- 逻辑地址：是指计算机用户看到的地址。
- 虚拟内存：是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。



## 14、页面置换算法有哪些

请求调页，也称按需调页，即对不在内存中的“页”，当进程执行时要用时才调入，否则有可能到程序结束时也不会调入。常用的页面置换算法如下：

- **先进先出置换算法**：先进先出，即淘汰最早调入的页面
- **最佳置换算法**：选未来最远将使用的页淘汰，是一种最优的方案
- **最近最久未使用（LRU）算法**
- **时钟（Clock）置换算法**





## 15、























