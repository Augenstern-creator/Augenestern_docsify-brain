# 1、Zookeeper

Zookeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。Zookeeper的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。







## 1.1、ZooKeeper 适合哪些应用场景

ZooKeeper 适用于以下应用场景：

1. 分布式服务注册与订阅：在分布式环境中，为了保证高可用性，通常同一个应用或同一个服务的提供方都会部署多份，达到对等服务。而消费者就需要在这些对等的服务器中选择一个来执行相关的业务逻辑，比较典型的服务注册与订阅，如 Dubbo。
2. 分布式配置中心：发布与订阅模型，即所谓的配置中心，顾名思义就是发布者将数据发布到 ZooKeeper 节点上，供订阅者获取数据，实现配置信息的集中式管理和动态更新。
3. 命名服务：在分布式系统中，通过命名服务客户端应用能够根据指定名字来获取资源、服务地址和提供者等信息。
4. 分布式锁：这个主要得益于 Zookeeper 为我们保证了数据的强一致性。
5. 数据发布和/订阅：主要的一个场景，比如配置中心。
6. 负载均衡：能够基于域名服务，进行应用的负载，从而达到请求负载到各个应用中。
7. 分布式协调/通知：对于一个在多台机器部署运行的应用上，通常都需要一个协调者来控制整个系统的运行流程。
8. 集群管理：在集群环境中，机器和应用都是分散着进行部署，每次进行服务的上下线升级的过程中，都要手动进行集群的管理，这样造成人做的事比较重复性，并且也比较麻烦容易出错。
9. Master选举。
10. 分布式队列。



## 1.2、简述Zookeeper 目录结构和作用 ？

Zookeeper的目录结构是基于层次型的目录树，它对树中的节点进行有效管理，从而可以设计出多种多样的分布式的数据管理模型。Zookeeper的作用主要是用来维护和监控存储的数据的状态变化，通过监控这些数据状态的变化，从而可以达到基于数据的集群管理。它并不是用来专门存储数据，而是用于维护和监控数据的状态变化。



## 1.3、简述Zookeeper的工作原理 ？

Zookeeper的工作原理主要基于原子广播机制，实现这个机制的协议叫做Zab协议。

- Zab协议有两种模式，它们分别是恢复模式和广播模式。当服务启动或者在领导者崩溃的时候，Zab就进入了恢复模式，当领导者被选举出来，且大多数server完成了和leader的状态同步之后，恢复模式就结束了。
- 状态同步保证了leader和server具有相同的系统状态。在广播模式下，当一个server加入zookeper服务中，它会在恢复模式下启动，发现leader并和leader进行状态的同步，待到同步结束，它也参与消息广播。Zookeeper服务一直维持在Broadcast状态，直到leader崩溃了或者leader失去了大部分的follower。





## 1.4、简述zoo.cfg 配置项目和对应的作用

Zoo.cfg配置文件是Zookeeper的核心配置文件，其中可以配置的参数有：

1. clientPort：用于配置当前服务器对客户端暴露的端口，一般配置为2181，无默认值。
2. dataDir：用于配置Zookeeper服务器存储快照文件(Zookeeper 节点数据)的目录，无默认值。
3. dataLogDir：用于配置服务器存储事务日志文件的目录，有默认值dataDir，但是建议将两个目录分别配置，防止磁盘的并发读写，影响服务器性能。可将其配置在一个单独的磁盘上。
4. tickTime：心跳时间，用于配置服务器最小时间的单位，默认值3000ms，心跳检测时间通常是该单位的倍数。如客户端与服务端之间的会话超时时间在2tickTime~20tickTime之间。
5. initLimit：用于配置leader服务器等待Follower服务器启动，并完成数据同步的时间，默认为10，表示10*tickTime。
6. syncLimit：用于配置leader服务器和Follower服务器之间进行心跳检测的最大延时时间，默认为5，表示5*tickTime。
7. minSessionTimeout和maxSessionTimeout：用于服务端对客户端会话超时时间的限制，也就是客户端自定义的超时时间必须在minSessionTimeout~maxSessionTimeout内，其默认为分别为2和20，时间表示为2tickTime~20tickTime。
8. maxClientCnxns：从socket层面限制单个客户端和单台服务器之间的最大并发连接数，即以IP地址粒度来进行连接数的限制，如果为0，表示不作限制，默认为60。
9. clientPortAddress：针对多网卡的机器，该参数允许为每个IP地址指定不同的监听端口。
10. server.id=host:port:port：用于配置组成Zookeeper集群的机器列表，其中id为serverId，与myid文件中的值对应。第一个端口用于指定Leader服务器和Follower服务器进行运行时通信和数据同步所使用的端口，第二个端口用于进行Leader选举过程中的投票通信。
11. autopurge.snapRetainCount：用于配置Zookeeper在自动清理的时候需要保留的快照数据文件数量和对应的事务日志文件，默认为3，自定义值小于3也会取值3。

这些参数可以用来配置Zookeeper服务器的各个方面的行为，包括端口号、数据存储目录、心跳检测机制、集群模式等。在具体使用时，需要根据实际情况进行配置。





## 1.5、列举Zookeeper的常用命令

Zookeeper的常用命令包括：

1. 启动Zookeeper服务：bin/zkServer.sh start
2. 查看 Zookeeper状态：bin/zkServer.sh status
3. 停止 Zookeeper服务：bin/zkServer.sh stop
4. 重启 Zookeeper服务：bin/zkServer.sh restart
5. 连接服务器：zkCli.sh -server 192.168.1.2:2181
6. 查看根目录：ls /
7. 创建节点：create /zk myDate
8. 查看节点内容： get /zk
9. 设置节点内容： set /zk myBook
10. 删除节点： delete /zk

这些命令可以在Zookeeper的CLI环境下使用，用于管理Zookeeper服务器的状态、连接、节点创建、内容查看、修改和删除等操作。





## 1.6、Zookeeper客户端与服务端之间的的连接称之为什么？

Zookeeper客户端与服务端之间的连接称为会话（session）。

- 在Zookeeper中，一个客户端连接是指客户端和服务器之间的一个TCP长连接。
- 客户端启动的时候，首先会与服务器建立一个TCP连接，从第一次连接建立开始，客户端会话的生命周期也开始了。通过这个连接，客户端能够通过心跳检测与服务器保持有效的会话，也能够向Zookeeper服务器发送请求并接受响应，同时还能够通过该连接接收来自服务器的Watch事件通知。

## 1.7、简述Zookeeper的watcher机制

Zookeeper的watcher机制是一种实现分布式数据发布/订阅功能的方式，它允许客户端向服务端注册一个watcher监听，当服务器的一些特定事件触发这个watcher时，就会向指定客户端发送一个事件通知。这种机制可以帮助实现分布式的通知功能。在Zookeeper中，watcher机制主要包括客户端线程、客户端WatchManager和ZooKeeper服务器三部分。

- 客户端向服务端注册watcher，当服务器的一些特定事件触发了这个watcher，就会向指定客户端发送一个事件通知。
- 触发事件种类很多，如：节点创建，节点删除，节点改变，子节点改变等。

Watcher机制可以概括为以下三个过程：客户端向服务端注册Watcher、服务端事件发生触发Watcher、客户端回调Watcher得到触发事件情况。



## 1.8、Zookeeper集群不得少于几台服务器，集群规则是什么

Zookeeper集群不得少于三台服务器，因为Zookeeper通过存活节点数数量是否大于总节点数一半来判断服务是否可以。

- 例如三个节点，挂掉了2个表示整个集群挂掉，而用偶数4个，挂掉了2个，剩下的2个节点并没有超过半数，因此也会挂掉。
- 集群最好是在不同的物理机上，本案例因生产环境因素，搭建在一台物理机上，因此也叫伪集群，但差别不是很大，只是ip地址不同。







## 1.9、Zookeeper有哪几种几种部署模式

Zookeeper有三种部署模式，分别是单机模式、伪集群模式和集群模式。

1. 单机模式：一般用来检验Zookeeper基础功能，熟悉Zookeeper各种基础操作及特性。
2. 伪集群模式：在单台机器上部署集群，方便在本地验证集群模式下的各种功能。
3. 集群模式：一般在生产环境使用，具备一致性、分区容错性。



## 1.10、请描述 Zookeeper 的通知机制是什么

Zookeeper 的通知机制是一种观察者（watcher）模式，允许客户端在关心的目录节点上设置观察，当节点发生改变时，Zookeeper 会通知设置过观察的客户端。

通知机制是异步回调的触发机制，Zookeeper 支持在 getData()、getChildren() 和 exists() 操作中设置 watcher，当被观察服务端的 znode 节点有变更，那么 watcher 就会被触发，这个 watcher 所属的客户端就会收到一个通知包，告知节点已经发生变化。





## 1.11、列举Znode节点有哪些类型 

Zookeeper 中的 Znode 节点有以下四种类型：

1. PERSISTENT（永久节点）：从一开始被创建就会永久存在，直到被主动删除。这种类型的节点不会因为客户端会话的断开而被删除。
2. PERSISTENT_SEQUENTIAL（永久有序节点）：与 PERSISTENT 类似，唯一的区别是节点名会被追加一个单调递增的十进制序号。
3. EPHEMERAL（临时节点）：这种类型的节点被客户端创建，当客户端断开连接时，该节点就会被删除。
4. EPHEMERAL_SEQUENTIAL（临时有序节点）：与 EPHEMERAL 类似，但节点名会被追加一个单调递增的十进制序号。当客户端断开连接时，该节点同样会被删除。



## 1.12、请问Znode节点状态stat的属性 

Znode节点状态stat的属性包括：

1. cZxid：数据节点创建时的事务id。
2. mZxid：数据节点最后一次更新的事务id。
3. pZxid：数据节点的子节点最后一次被修改时的事务ID。
4. ctime：数据节点创建时的时间。
5. mtime：数据节点最后一次更新的时间。
6. dataVersion：节点数据的更改次数。
7. cversion：子节点的更改次数。
8. aclVersion：节点的ACL（权限列表）的更改次数。
9. ephemeralOwner：如果znode是临时节点，则这是znode所有者的session ID。如果znode不是临时节点，则该字段设置为0。
10. dataLength：这是znode数据字段的长度。



## 1.13、请简述Znode的结构 ?

Znode是Zookeeper中的节点，它兼具文件和目录两种特性。每个Znode都维护着数据、元信息、ACL（访问控制列表）和时间戳等数据结构。

每个Znode由三部分组成：

1. stat：维护Znode的状态信息，包括版本号、权限等信息。
2. data：与该Znode关联的数据。
3. children：该Znode下的子节点。

此外，Zookeeper虽然可以关联一些数据，但并没有被设计为常规的数据库或者大数据存储。相反的是，它用来管理调度数据，比如分布式应用中的配置文件信息、状态信息、汇集位置等等。这些数据的共同特性就是它们都是很小的数据，通常以KB为大小单位。



## 1.14、简述watcher使用场景 ？

Watcher的使用场景包括但不限于以下几种情况：

1. **数据发布/订阅**：在分布式环境中，Zookeeper允许发布者将数据发布到节点上，供订阅者进行数据订阅，实现配置信息的集中式管理和数据的动态更新。这种模式有两种设计模式，推模式和拉模式。
2. **集群状态感知**：Watcher可以用于感知集群中的变化，例如，当有新的服务器加入集群时，可以在Zookeeper的特定节点上设置Watcher，一旦集群中有了变化，Watcher就会被触发并通知客户端。
3. **分布式通知**：Watcher可以用于实现分布式通知，例如，当一个分布式任务完成时，可以在Zookeeper的特定节点上设置Watcher，一旦任务完成，Watcher就会被触发并通知客户端。
4. **配置管理**：Watcher可以用于配置管理，例如，可以在Zookeeper的特定节点上保存配置信息，一旦配置信息发生变化，Watcher就会被触发并通知客户端。

总的来说，Watcher适用于需要监控分布式系统中特定事件或状态变更的场景。



## 1.15、简述Zookeeper的监听原理

Zookeeper的监听原理基于观察者模式实现。客户端注册监听它关心的目录节点，当目录节点发生变化（数据改变、节点删除、子目录节点增加删除）时，Zookeeper会通知客户端。

具体来说，客户端在注册监听器时会将节点路径和监听器信息传递给服务端。服务端在接收到客户端的请求后会将节点路径和客户端连接信息存储在服务端的WatchManager中。当客户端的目录节点发生变化时，服务端会向客户端发送事件通知，客户端在接收到通知后执行监听器的回调方法。

这种监听机制可以保证Zookeeper保存的任何数据改变都能快速响应到监听了该节点的应用程序中。







## 1.16、Zookeeper负载均衡和Nginx负载均衡有什么区别

Zookeeper负载均衡和Nginx负载均衡的区别主要体现在以下三个方面：

1. **负载均衡的目的**：Zookeeper负载均衡的目的是通过将服务注册到Zookeeper注册中心，建立一个树形的服务结构，然后通过查找能提供所需服务的服务器列表，根据负载均衡算法从中选取一台服务器进行连接。其主要用于实现服务的动态发现和负载均衡。而Nginx负载均衡的主要目的是将多个web server配置到Nginx中，用户访问Nginx时，就会自动被分配到某个web server upstream。
2. **实现方式**：Zookeeper负载均衡的实现思路是将每个服务注册到Zookeeper注册中心，每台服务器知道自己是属于哪个服务，在服务器启动时，自己向所属服务进行登记，这样，一个树形的服务结构就呈现出来了。服务的调用者到注册中心里面查找能提供所需服务的服务器列表，然后自己根据负载均衡算法，从中选取一台服务器进行连接。而Nginx的负载均衡配置非常简单，把多个web server配置到Nginx中，用户访问Nginx时，就会自动被分配到某个web server upstream。
3. **适用场景及优缺点**：Zookeeper负载均衡适用于服务数量和服务集群规模较大，需要进行动态服务发现和负载均衡的场景。其优点在于可以实现动态服务发现和负载均衡，并且具有高可用性和可扩展性。但是，随着整个系统的演进，服务的数量会不断增加，每个服务集群中的服务器数量也会增加，这可能会导致配置维护的成本变高，并且存在单点故障的风险。而Nginx负载均衡适用于服务拆分、各个服务独立部署、通过远程调用方式协同工作的场景。其优点在于配置简单、性能高、稳定性好，可以作为反向代理、静态文件服务器等。但是，如果服务规模很大或者需要更复杂的负载均衡策略时，Nginx可能无法满足需求。



## 1.17、Zookeeper节点宕机如何处理？

在Zookeeper中，如果一个节点宕机，可以采取以下措施：

1. 故障恢复操作：一旦监测到Zookeeper节点宕机，可以执行故障恢复操作，例如重新创建节点、通知相关服务，或者执行其他适当的操作。这取决于具体应用场景。
2. 高可用架构：为了提高Zookeeper的可用性，可以考虑使用Zookeeper的集群，以便在一个节点宕机时其他节点仍然可用。确保Zookeeper集群配置正确，并且有足够的节点来容忍故障。在Zookeeper集群中，当一个节点宕机时，其上的数据副本将仍然存在，因此数据不会丢失。如果是一个Follower节点宕机，还有2台服务器提供访问，因为Zookeeper上的数据是有多个副本的；如果是一个Leader节点宕机，Zookeeper会选举出新的Leader。





## 1.18、ZooKeeper 集群中个服务器之间是怎样通信的？

在ZooKeeper集群中，各个服务器之间通过TCP协议进行通信。每个服务器都会创建一个叫做LearnerHandler的实体，它主要负责Leader和Follower之间的网络通讯，包括数据同步、请求转发和Proposal提议的投票等。



ZooKeeper集群通信采用的是主从模式，其中包括一个Leader节点和多个Follower节点。在正常运作的情况下，Leader节点负责处理客户端请求和事务处理，而Follower节点则负责与Leader节点进行通信并同步数据。当一个Follower节点变成了新的Leader，它会将Follower的数据复制到新的Leader上，并更新系统状态。



ZooKeeper集群中的每个节点都可以成为Leader，当一个Follower节点发现Leader节点失效时，它会通过选举算法选举出新的Leader。选举过程中，各个Follower节点会互相发送消息来保持状态的同步，包括心跳消息、请求消息和响应消息等。



ZooKeeper提供了基于类似Linux文件系统的目录节点树方式的数据存储，即分层命名空间。这种数据存储方式使得ZooKeeper可以很方便地管理分布式系统中的各种配置信息、命名服务、状态管理等等。





## 1.19、客户端修改了某个节点的数据，其他客户端能够马上获取到这个最新数据吗？

是的，其他客户端可以立即获取到更新的数据。在ZooKeeper中，当一个客户端修改了某个节点的数据后，会触发一个watch通知给所有对该节点设置watch的客户端。这些客户端会立即收到更新后的数据。因此，只要在客户端修改数据后，其他客户端就可以立即获取到最新的数据。







## 1.20、简述Zookeeper和Dubbo的关系 ？

Zookeeper和Dubbo是两个相互依存的关系：

1. Zookeeper是一个分布式协调服务，被用于构建分布式系统的基础设施，提供了分布式锁、分布式队列等机制，并可以被用于服务的注册与发现、配置中心等场景。Dubbo则是一个高性能的JavaRPC框架，用于提供服务的管理和调用机制。
2. Dubbo将自身作为一个服务，通过Zookeeper将自身注册到Zookeeper集群中，并在消费方从Zookeeper中发现并订阅服务。Zookeeper则提供一个平台，支持Dubbo实现服务的注册、发现、负载均衡和容错等功能。
3. Dubbo对Zookeeper的依赖主要表现在服务注册与发现机制上。Zookeeper的特性，包括负载均衡、资源同步、命名服务等，都被Dubbo借鉴和使用。

## 1.22、请说明ZooKeeper使用到的各个端口的作用？

ZooKeeper使用的端口主要有三个，分别是2181、3888和2888。

1. 2181端口：主要用于对客户端提供服务。
2. 3888端口：主要用于选举leader。
3. 2888端口：主要用于集群内机器通讯，特别是在Leader监听此端口。

在部署时，单机单实例只需端口不被占用即可。如果是单机伪集群（如在单机上部署多个实例），则三个端口必须修改且组组不一样。例如，myid1 : 2181,3888,2888，myid2 : 2182,3788,2788，myid3 : 2183,3688,2688。如果是集群环境（一台机器部署一个实例），其基数应大于等于3，例如3、5、7等，但不宜太多，因为机器多了可能导致选举和数据同步耗时长，使集群不稳定。





